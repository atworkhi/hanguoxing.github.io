{"meta":{"title":"懒散的小星星","subtitle":"吃饭睡觉打豆豆","description":"我说自己很好看你信吗？？？","author":"韩星星","url":"http://atworking.cn","root":"/"},"pages":[{"title":"","date":"2019-05-25T04:57:49.781Z","updated":"2019-05-25T04:57:49.781Z","comments":true,"path":"404.html","permalink":"http://atworking.cn/404.html","excerpt":"","text":""},{"title":"相册","date":"2019-04-22T04:12:59.000Z","updated":"2019-04-23T02:09:41.154Z","comments":false,"path":"photos/index.html","permalink":"http://atworking.cn/photos/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-22T04:12:59.000Z","updated":"2019-04-23T02:12:16.323Z","comments":false,"path":"about/index.html","permalink":"http://atworking.cn/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-22T04:12:59.000Z","updated":"2019-04-22T07:29:57.680Z","comments":false,"path":"tags/index.html","permalink":"http://atworking.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-22T04:14:13.000Z","updated":"2019-04-22T07:29:47.904Z","comments":false,"path":"categories/index.html","permalink":"http://atworking.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++基础知识07","slug":"C-基础知识07","date":"2019-05-29T11:29:01.000Z","updated":"2019-05-30T11:42:24.147Z","comments":true,"path":"2019/05/29/C-基础知识07/","link":"","permalink":"http://atworking.cn/2019/05/29/C-基础知识07/","excerpt":"第七章：函数探幽","text":"第七章：函数探幽","categories":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/tags/C/"}]},{"title":"C++基础知识06","slug":"C-基础知识06","date":"2019-05-27T12:47:23.000Z","updated":"2019-05-30T07:14:11.000Z","comments":true,"path":"2019/05/27/C-基础知识06/","link":"","permalink":"http://atworking.cn/2019/05/27/C-基础知识06/","excerpt":"第六章：函数","text":"第六章：函数 函数的基本知识使用函数必须遵守以下几点 提供函数定义； 提供函数原型； 调用函数。 函数定义可以将函数分成两类：没有返回值的函数和有返回值的函数。 没有返回值的函数被称为void函数 void funName(paraList){ xxxx; return; } 有返回值的函数将生成一个值，并将它返回给调用函数 typeName funName(paralist){ xxxx; return value; } 函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据 函数原型函数原型： 原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器 double value = add(num); 原型告诉编译器，add( )有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，add( )函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数（这里为main( )）将从这个位置取得返回值。由于原型指出了add( )的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。 使用原型：编译器如果在文件中一步步查找，效率是不高的，并且C++允许将一个程序放在多文件中，单独编译这些文件。这种情况下，编译器在编译main时，可能无权访问函数代码。如果函数位于库种，也是如此。 原型语法 函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号,函数原型不需要提供变量名，有类型列表就行。 double add(double num) void result(int) 原型功能 编译器正确处理函数返回值； 编译器检查使用的参数数目是否正确； 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话） 函数参数和按值传递C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其赋给一个新的变量。用于接收传递值的变量被称为形参。传递给函数的值被称为实参。出于简化的目的，C++标准使用参数（argument）来表示实参，使用参量（parameter）来表示形参，因此参数传递将参量赋给参数 在函数中声明的变量（包括参数）是该函数私有的。在函数被调用时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些变量使用的内存，这样的变量被称为局部变量，因为它们被限制在函数中，这样做有助于确保数据的完整性。 多个参数 函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可，同样，在定义函数时，也在函数头中使用由逗号分隔的参数声明列表。 函数和数组函数参数和返回值的类型可以是基本类型，也可以是处理更复杂的类型（如数组和结构） 使用指针处理数组C++和C语言一样，也将数组名视为指针，C++将数组名解释为其第一个元素的地址(arrName=&amp;arrName[0]),该规则有一些例外,首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个数组的长度,第三将地址运算符&amp;用于数组名时，将返回整个数组的地址，例如&amp;cookies(cookies长度为8)将返回一个32字节内存块的地址（如果int长4字节）。 int sum = sum_arr(cookies, length) //调用 int sum_arr(int * arr, int n) //原型 cookies是数组名，而根据C++规则，cookies是其第一个元素的地址，因此函数传递的是地址。由于数组的元素的类型为int，因此cookies的类型必须是int指针，即int 。其中用int arr替换了int arr [ ]。这证明这两个函数头都是正确的，因为在C++中，当（且仅当）用于函数头或函数原型中，int arr和int arr [ ]的含义才是相同的。它们都意味着arr是一个int指针。然而，数组表示法（int arr[ ]）提醒用户，arr不仅指向int，还指向int数组的第一个int。当指针指向数组的第一个元素时，可以使用数组表示法，而当指针指向一个独立的值时，使用指针表示法。在其他的上下文中，int arr和int arr [ ]的含义并不相同。例如，不能在函数体中使用int tip[ ]来声明指针。 鉴于变量arr实际上就是一个指针，函数的其余部分是合理的，将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型的长度（以字节为单位）相等的值。对于遍历数组而言，使用指针加法和数组下标时等效的。记住下面两个恒等式 arr[i] == *(ar+i) &amp;arr[i]==ar+i 将数组作为参数代表什么函数调用sum_arr(coolies, ArSize)将cookies数组第一个元素的地址和数组中的元素数目传递给sum_arr( )函数。sum_arr( )函数将cookies的地址赋给指针变量arr，将ArSize赋给int变量n。意味着：实际上并没有将数组内容传递给函数，而是将数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数有了这些信息后，函数便可以使用原来的数组。传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。实际上，这种区别并不违反C++按值传递的方法，sum_arr( )函数仍传递了一个值，这个值被赋给一个新变量，但这个值是一个地址，而不是数组的内容。 数组名与指针对应是好事吗？确实是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。在经典的C语言中，这确实是一个问题，但ANSI C和C++中的const限定符提供了解决这种问题的办法。 更多数组函数示例选择使用数组来表示数据时，实际上是在进行一次设计方面的决策。但设计决策不仅仅是确定数据的存储方式，还涉及到如何使用数据。编写特定的函数来处理特定的数据操作是有好处的（这里讲的好处指的是程序的可靠性更高、修改和调试更为方便）。另外，构思程序时将存储属性与操作结合起来，便是朝OOP思想迈进了重要的一步；以后将证明这是很有好处的。 填充数组 由于接受数组名参数的函数访问的是原始数组，而不是其副本，因此可以通过调用该函数将值赋给数组元素。该函数的一个参数是要填充的数组的名称 int fill_arr(double ar[], int limit) //原型 该函数接受两个参数，一个是数组名，另一个指定了要读取的最大元素数；该函数返回实际读取的元素数，如果是5个元素，例如，如果使用该函数来处理一个包含5个元素的，则将5作为第二个参数。 可以使用循环连续地将值读入到数组中，但如何提早结束循环呢？一种方法是，使用一个特殊值来指出输入结束。由于所有的属性都不为负，因此可以使用负数来指出输入结束。另外，该函数应对错误输入作出反应，如停止输入等。 1234567891011121314151617181920int fill_arr(double ar[], int limit)&#123; using namespace std; double temp; int i; for (i=0; i&lt; limit; i++)&#123; cout&lt;&lt;\"Enter value #\"&lt;&lt;(i+1)&lt;&lt;\": \"; cin &gt;&gt; temp; if (!cin)&#123; //非法输入 cin.clear()； while (cin.get()!='\\n') continue; cout&lt;&lt;\"bad input. \\n\" break; &#125; else if (temp &lt;0) break; ar[i] = temp; &#125; return i;&#125; 输入非负值，将赋值给数组，否则循环结束，如果用户输入的都是有效值，则循环将在读取最大数目的值后结束。循环完成的最后一项工作是将i加1，因此循环结束后，i将比最后一个数组索引大1，即等于填充的元素数目。然后，函数返回这个值。 显示数组及用const保护数组 创建显示数组内容的函数，只需将数组名和填充的元素数目传递给函数，然后该函数使用循环来显示每个元素。确保显示函数不修改原始数组。除非函数的目的就是修改传递给它的数据，否则应避免发生这种情况。使用普通参数时，这种保护将自动实现，由于C++按值传递数据，而且函数使用数据的副本，接受数组名的函数将使用原始数据，这正是fill_array( )函数能够完成其工作的原因。为防止函数无意中修改数组的内容，可在声明形参时使用关键字const void show_arr(const double ar[], int n) 该声明表明，指针ar指向的是常量数据。这意味着不能使用ar修改该数据，也就是说，可以使用像ar[0]这样的值，但不能修改。注意，这并不是意味着原始数组必须是常量，而只是意味着不能在show_array( )函数中使用ar来修改这些数据。因此，show_array( )将数组视为只读数据 如果对数组进行改变(ar[0]+=10)，则回出现错误(cannot modify a const) 1234567//显示数组void show (const int num[], int n)&#123; using namespace std； for (int i=0; i&lt;n; i++)&#123; cout &lt;&lt;num[i]&lt;&lt;endl; &#125;&#125; 修改数组 函数将修改数组的值，因此在声明ar时，不能使用const。 数组处理函数常用的编写方式 处理double数组的函数 void f_modify(double arr[],int n); //可修改 void f_nochange(const double arr[],int n); //不修改 使用数组区间的函数处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量提交给它；传统的C/C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供了找到所有数据所需的信息 另一种给函数提供所需信息的方法，即指定元素区间（range），这可以通过传递两个指针来完成：一个指针标识数组的开头，另一个指针标识数组的尾部 int sum_arr(const int begin, const int end); //声明 int sum = sum_arr(cookies, cookies+size); //调用 for (pt = begin; pt != end; pt++){ *pt; } //循环取值 指针和const可以用两种不同的方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值,第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。 int age =10 ;const int * p = &age; p为const不能通过p来修改值。当时age不是const，可以通过age修改。 指针和变量 是否可行 常规变量的地址赋给常规指针 可以 常规变量的地址赋给指向const的指针 可以 const变量的地址赋给指向const的指针 可以 const的地址赋给常规指针 不可以 注意：const只能防止修改指向的值，但是不能防止修改p的值 int sage=20; p=&amp;sage //ok 但事不能修改saged的值 下面这种声明使得p只能指向n,但是允许使用p 来修改n得值。 int n =1; int * const p = &n; 还可以声明const对象得const指针 int n =2 ; const int const p = &n; //p只能指向n,p还不能修改n得值。p和p均是const 函数和二维数组将二维数组作为参数的函数，必须牢记，数组名被视为其地址，因此，相应的形参是一个指针，就像一维数组一样。比较难处理的是如何正确地声明指针。 1234567891011int data[2][3]=&#123;&#123;1，2，3&#125;,&#123;4，5，6&#125;&#125;；int total =sum(data，2)；/* Date是一个数组名，里面含有3个元素，第一个元素本身四个数组，由3个int组成，因此data类型是由3个int组成的指针 声明如下：int sum(int (*ar)[3]，int size)；括号是必不可少的，因为下面的声明将声明一个由3个指向int的指针组成的数组，而不是由一个指向由3个int组成的数组的指针 还可以声明：int sum(int ar[][3]，int size)；ar是指针而不是数，它指向由3个int组成的数组。因此，指针类型指定了列数，这就是没有将列数作为独立的函数参数进行传递的原因*/ 函数和char字符串字符串由一系列字符组成，以空值字符结尾， 字符串与常规char数组之间的一个重要区别是，字符串有内置的结束字符，必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。 char指针(char *)类型字符串的三种表示方法 : char a[10] = “hello”; char * str = “hello” char数组；void fun1 = str(a) 用引号括起的字符串常量（也称字符串字面值）；void fun1 = str(“hello”) 被设置为字符串的地址的char指针。void fun1 = str(str) 函数无法返回一个字符串，但可以返回字符串的地址，这样做的效率更高。函数返回一个指针。该函数接受两个参数：一个字符和一个数字。函数使用new创建一个长度与数字参数相等的字符串，然后将每个元素都初始化为该字符。然后，返回指向新字符串的指针。 函数和结构体与数组不同，结构将其数据组合成单个实体或数据对象，该实体被视为一个整体。可以按值传递结构，就像普通变量那样。在这种情况下，函数将使用原始结构的副本。另外，函数也可以返回结构。与数组名就是数组第一个元素的地址不同的是，结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&amp;。在C语言和C++中，都使用符号&amp;来表示地址运算符；另外，C++还使用该运算符来表示引用变量。按值传递结构有一个缺点。如果结构非常大，则复制结构将增加内存要求，降低系统运行的速度。出于这些原因，许多C程序员倾向于传递结构的地址，然后使用指针来访问结构的内容。 传递和返回结构当结构比较小时，按值传递结构最合理 结构体 sum(结构体1 结构体2) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;struct time&#123; //定义结构体 int hours； int mins；&#125;；const int pre =60；time sum(time t1，time t2)； //定义函数 传递两个结构体，返回结构体void show_time(time t)； //显示结果int main()&#123; using namespace std； time time1=&#123;3,2&#125;; time time2=&#123;5,8&#125;; time result=sum(time1,time2); //引用函数 show_time(result); //显示结果 return 0；&#125;//结构体函数实现time sum(time t1,time t2)&#123; titme total; total.mins=(t1.mins+t2.mins)%pre; total.hours=t1.hours+t2.hours+(t1.mins+t2.mins)/pre; return total;&#125;//显示函数void show_time(time t)&#123; using namespace std; cout &lt;&lt; t.hours&lt;&lt;\":\"&lt;&lt;\"t.mins\"&lt;&lt;endl;&#125; 处理函数和结构体第二个方法这个例子将定义两个结构，用于表示两种不同的描述位置的方法，然后开发一个函数，将一种格式转换为另一种格式，并显示结果. 描述屏幕上的某个坐标使用x表示水平偏移量，使用y表示垂直偏移量(用坐标结构体表示位置)，另一种描述点的位置的方法是，指出它偏离原点的距离和方向（例如，东偏北40度）。数学家从正水平轴开始按逆时针方向度量角度距离和角度一起构成了极坐标(polar结构体)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cmath&gt;//坐标结构体struct rect&#123; double x; double y;&#125;;//polar结构体struct polar&#123; double distance; double angle;&#125;;/*创建一个显示polar内容的函数，角度约为：57.29577951形参的类型为polar。将一个polar结构传递给该函数时，该结构的内容将被复制到dapos结构中，函数随后将使用该拷贝完成工作*/void show_polar(polar dapos)&#123; using namespace std; const num=57.29577951; cout &lt;&lt; \"distance=\"&lt;&lt;dapos.distance; cout &lt;&lt; \"angle=\"&lt;&lt;dapos.angle*num; cout &lt;&lt;\"show_polar over\\n\";&#125;//编写一个将直角坐标转换极坐标的函数。参数接受rect ,返回polar//数学知识用到头文件 cmath（毕达哥拉斯定力）polar rect_to_polar(rect xy)&#123; polor result; result.distance=sqrt(xy.x*xy.x+xy.y*xy.y); result.angle=atan2(xy.y,xy.x); return result;&#125;//mainint main()&#123; using namespace std; rect rp; polar pp; cout&lt;&lt;\"输入x和y的值:\"; //cin控制循环，如果输入不符合内容退出 while(cin &gt;&gt; rp.x &gt;&gt; rp.y)&#123; pp = rect_to_polar(rp); show_show_polar(pp); cout&lt;&lt;\"下一组数据(q 退出)\"; &#125; cout&lt;&lt;\"over.\\n\"; return 0;&#125; 传递结构地址假设要传递结构的地址而不是整个结构以节省时间和空间，则需要重新编写前面的函数，使用指向结构的指针。 123456789101112131415161718192021222324252627282930313233//声明void rect_to_polar(const rect * pxy, polar* pda);void show_polar(const polar *pda);//重写调用时将指针传入，形参也修改指针，需要使用-&gt;间接成员void show_polar(const polar *pda)&#123; using namespace std; const num=57.29577951; cout &lt;&lt; \"distance=\"&lt;&lt;pda-&gt;distance; cout &lt;&lt; \"angle=\"&lt;&lt;pda-&gt;angle*num; cout &lt;&lt;\"show_polar over\\n\";&#125;//重写转换 传入指针，也是结构体本身不是副本void rect_to_polar(const rect *xy, polar *pa)&#123; using namespace std; pa-&gt;distance=sqrt(xy-&gt;x*xy-&gt;x+xy-&gt;y*xy-&gt;y); pa-&gt;angle=atan2(xy-&gt;y,xy-&gt;x);&#125;//重写mainint main()&#123; using namespace std; rect rp; polar pp; cout&lt;&lt;\"输入x和y的值:\"; //cin控制循环，如果输入不符合内容退出 while(cin &gt;&gt; rp.x &gt;&gt; rp.y)&#123; rect_to_polar(&amp;rp, &amp;pp) show_show_polar(&amp;pp); cout&lt;&lt;\"下一组数据(q 退出)\"; &#125; cout&lt;&lt;\"over.\\n\"; return 0;&#125; 函数和string对象tring对象与结构的更相似。例如，可以将一个结构赋给另一个结构，也可以将一个对象赋给另一个对象。可以将结构作为完整的实体传递给函数，也可以将对象作为完整的实体进行传递。如果需要多个字符串，可以声明一个string对象数组，而不是二维char数组。 除函数getline( )外，应像对待内置类型（如int）一样对待string对象。如果需要string数组，只需使用通常的数组声明格式即可：string list[size];数组list的每个元素都是一个string对象，可以像下面这样使用它:getline(cin,list[i]) 函数和array对象在C++中，类对象是基于结构的，因此结构编程方面的有些考虑因素也适用于类。例如，可按值将对象传递给函数，在这种情况下，函数处理的是原始对象的副本。另外，也可传递指向对象的指针，这让函数能够操作原始对象。 用array类，需要包含头文件array，而名称array位于名称空间std中。如果函数来显示expenses的内容，可按值传递expenses:show(xxx); 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;string&gt;const int season=4; //常量//四季的array 在函数声明之前，都可以使用const std::array&lt;std::string,season&gt; arr=&#123;\"spring\",\"summer\",\"fall\",\"winter\"&#125;; void fill(std::array&lt;double,season&gt; *pa); //声明void show (std::array&lt;double,season&gt; da);int main()&#123; std::array&lt;double,season&gt; expenses; fill(&amp;expenses); //传入指针 show(expenses); //值传递 return 0;&#125;void fill(std::array&lt;double,season&gt; *pa)&#123; using namespace std; for (int i=0; i&lt;season;i++)&#123; cout &lt;&lt;\"输入 \"&lt;&lt;arr[i]&lt;&lt;\" 收入：\"; //pa是一个arr对象的指针，而(*pa)[i]该对象的一个元素,由于运算符优先级的影响，其中的括号必不可少。 cin &gt;&gt; （*pa）[i]; &#125;&#125;void show (std::array&lt;double,season&gt; da)&#123; using namespace std; double total =0.0; for (int i=0; i&lt;season;i++)&#123; cout &lt;&lt; arr[i]&lt;&lt;\":$\"&lt;&lt;da[i]&lt;&lt;endl; total+=da[i]; &#125; cout&lt;&lt;\"total :$\"&lt;&lt;total&lt;&lt;endl;&#125; 递归函数调用自己称为递归。如果递归函数调用自己，则被调用的函数也将调用自己，这将无限循环下去，除非代码中包含终止调用链的内容。通常的方法将递归调用放在if语句中 1234567void fun (arglist)&#123; statments1; if (test) fun(arglist); statments2;&#125;test若为false，调用将终止 在需要将一项工作不断分为两项较小的、类似的工作时，递归非常有用。 函数指针与数据项相似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。 获取函数地址 只要使用函数名（后面不跟参数）。 fun1（fun）;//使fun1函数能够在其内部调用fun函数 fun1(fun()); //首先调用fun( )函数，然后将fun( )的返回值传递给fun1( )函数 声明函数指针 声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。 double fun(int) //函数类型 double(pt)(int); //指针声明 由于fun是函数，(\\pt)也是函数，pt就是指针 pt=fun; //将相应函数的地址赋给指针 必须在声明中使用(pt)(int)指 pt是一个返回函数的指针。\\pt(int) pt()是一个返回指针的函数。注意 函数声明和指针声明的返回值必须相同。 调用函数 double x= fun(10) //函数调用 double y = (*pt)(10);// 指针调用 double y = pt(5) ;//C++也允许像使用函数名那样使用pt 为何pf和（pf）等价呢？一种学派认为，由于pf是函数指针，而pf是函数，因此应将（*pf）( )用作函数调用。另一种学派认为，由于函数名是指向该函数的指针，指向函数的指针的行为应与函数名相似，因此应将pf( )用作函数调用使用。 函数指针示例：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;//函数声明double betsy(int);double pam(int);//函数指针作为参数的声明void estimate(int lines, double (*pt)(int));int main()&#123; using namespace std; int code; cout &lt;&lt; \"how many lines of code do you need:\"; cin &gt;&gt; code; cout &lt;&lt; \"here's besty estimate:\\n\"; //调用函数指针参数 estimate(code, betsy); cout &lt;&lt; \"here's pam estimate:\\n\"; estimate(code, pam); return 0;&#125;double betsy(int lns)&#123; return 0.05 * lns;&#125;double pam(int lns)&#123; return 0.03 * lns + 0.0004 * lns * lns;&#125;void estimate(int lines, double (*pt)(int))&#123; using namespace std; cout &lt;&lt; \"lines value:\" &lt;&lt; lines&lt;&lt;\"\\n\"; cout &lt;&lt; (*pt)(lines) &lt;&lt; \" hour(s)\\n\";&#125;-----------------------------------------------------how many lines of code do you need:100here's besty estimate:lines value:1005 hour(s)here's pam estimate:lines value:1007 hour(s) 探讨函数指针const double * f1 (const double arr[], int n) const double * f2 (const double [], int); const double f3 (const double , int); 上面三个函数原型表示的相同，因为可以省略标识符，const double * arr 和 const double[]相同。 const double (p1) (const double *, int); 指针的声明，指向上面三个函数原型 auto p2 =f2; //C++11的类型自动推导也可以 (p1)(av,3)和p2(av,3)都是指向调用函数，返回值是f1或f2的返回值。类型 const double (double值的地址)。如果需要取地址存储的实际值，需要 用*(*p1)(av,3)或*p2(av,3). const double (pt[3]) (const double *,int)={f1,f2,f3}; 以上语句是使用函数指针数组存储上面三个函数，pt是一个包含三个元素的数组，而加上表示就是pt是一个包含三个指针的数组， (const double ,int)表示每个指针指向的类型函数。const double *是返回值类型。这里不能使用auto，自动类型推断只能用于单值初始化，而不能用于初始化列表(可以 auto pt1 =pt)。 初始化：const double px = pt [0] (av,3) 或 （pt[1]）(av,3) 取值： double x = pt[0] (av,3); 或 (*pt[1])(av,3) 使用typedef简化 除auto外，C++还提供了其他简化声明的工具：typedef(创建类型别名) 问答 使用函数的三个步骤 声明 定义 调用 编写一个参数(int数组 长度 int值)，并将数组所有的元素设置这int值的函数 12345void fun (int arr[], int size, int value)&#123; for (int i = 0; i&lt;size;i++)&#123; arr[i] = value; &#125;&#125; 编写一个参数(数组第一个元素指针，最后一个元素指针，int值)，并把数组值赋给int的函数 12345void fun(int * begin, int * end, int value)&#123; for (int *p =begin; p != end;p++)&#123; p*=value; &#125;&#125; 不对类型为基本类型的函数参数使用const const 限定用于指针，房子指向原始的数据被修改，因为c++函数传递的为基本类型是按值传递。使用的副本，保护原始数据 函数原型 int fun(char * str, char c1,char c2)。c1替换c2 1234567891011int fun (char *str, char c1, char c2)&#123; int count =0 ; //返回替换次数 while(*str)&#123; //‘\\0’ if (*str==c1)&#123; *str =c2; count++; &#125; str++； //指针++ &#125; return count;&#125; 表达式*”abc”和”def”[2]表达什么 “abc”解释为第一个元素的地址，用*获取值也就是a;”def”为第一个元素地址，“def”[2]我第二个元素的值e.字符串常量的值与数组相同 结构的按值传递和传递地址利弊 按值传递，只需要传递结构名，这样自动保护原始数据，当时这是比较浪费时间和内存的；传递地址需要使用&amp;结构名，但是不能保护数据，除非对函数使用了const。按值传递可以使用常规的结构成员表示法(.)按指针传递必须使用间接成员运算符（-&gt;） 函数fun()返回类型为int，参数（const char指针作为参数并返回int值编）写原型 int fun(int (pt)(const char )); 结构体如下，编写函数 12345678910111213141516171819//结构体struct applicant&#123; char name[30]; int credit_ratings[3];&#125;;//1. 写一个函数，它将application结构作为参数，并显示该结构的内容，void show (applicant ap)&#123; cout &lt;&lt;ap.name &lt;&lt;endl; for (int i=0;i&lt;3;i++)&#123; cout &lt;&lt; ap.credit_ratings[i]&lt;&lt;endl; &#125;&#125;//2.编写一个函数，它将application结构的地址作为参数，并显示该参数指向的结构的内容（地址）void show (const applicant * pa)&#123; cout &lt;&lt;pa-&gt;name&lt;&lt;endl; for(int i=0; i&lt;3;i++)&#123; cout&lt;&lt;pa-&gt;credit_ratings[i]&lt;&lt;endl; &#125;&#125; 函数f1()和f2()的原型如下： 123456789void f1(applicant * a);const char * f2(const applicant *a1, const applicant *a2,);/* 将p1和p2分别声明为指向f1和f2的指针；将ap声明为一个数组，它包含5个类型与p1相同的指针；将pa声明为一个指针，它指向的数组包含10个类型与p2相同的指针。使用typedef来帮助完成这项工作。*/typedef void (*p_f1)(applicant *);p_f1 p1 = f1;typedef const char *(*p_f2)(const applicant *,const applicant *);p_f2 p2 = f2;p_f1 ap[5];p_f2 (*pa)[10]; 代码 输入最多10个数(可以小10)并存入数组中并回显，在求平均成绩.使用三个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;unsigned input(double num[], unsigned size)&#123; double tmp; unsigned numSize = 0; while (numSize &lt; size &amp;&amp; cin &gt;&gt; tmp &amp;&amp; tmp != -1) &#123; num[numSize++] = tmp; &#125; return numSize;&#125;void show(double numList[], unsigned size)&#123; for (unsigned i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; numList[i] &lt;&lt; ' '; &#125;&#125;double aver(double numList[], unsigned size)&#123; double sum = 0; for (unsigned i = 0; i &lt; size; ++i) &#123; sum += numList[i]; &#125; return (sum / size);&#125;int main(void)&#123; const unsigned k_size = 10; double numList[k_size]; cout &lt;&lt; \"enter 10 num, -1 over:\"; unsigned inputSize = input(numList, k_size); cout &lt;&lt; \"show list:\"; show(numList, inputSize); cout &lt;&lt; endl; cout &lt;&lt; \"ave=:\" &lt;&lt; aver(numList, inputSize); cout &lt;&lt; endl; return 0;&#125; 又个box结构体，编写函数按值传递结构，并显示每个成员的值，用函数传递box地址，并将成员volume设置为三维长度乘积。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;struct Tbox&#123; char szMaker[40]; float height; float width; float length; float volume;&#125;;void show(Tbox box)&#123; cout &lt;&lt; box.szMaker &lt;&lt; '\\t' &lt;&lt; box.height &lt;&lt; '\\t' &lt;&lt; box.width &lt;&lt; '\\t' &lt;&lt; box.length;&#125;float calc_volume(Tbox *p)&#123; return (p-&gt;volume = p-&gt;height * p-&gt;width * p-&gt;length);&#125;int main(void)&#123; Tbox box = &#123;\"boxbig\", 12, 10, 6, 0&#125;; show(box); cout &lt;&lt; endl; cout &lt;&lt; calc_volume(&amp;box); cout &lt;&lt; endl; return 0;&#125; 双色球中一等奖几率(33选6 16选1) 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;long double cal(unsigned numbers, unsigned picks)&#123; long double pro = 1.0; while (picks &gt; 0) &#123; pro *= 1.0 * numbers / picks; --numbers; --picks; &#125; return pro;&#125;int main(void)&#123; long double pro = cal(33, 6) * cal(16, 1); cout &lt;&lt; fixed &lt;&lt; pro &lt;&lt; \"\\\\1\"; cout &lt;&lt; endl; return 0;&#125; 递归求阶层 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;unsigned long long calc_factorial_less_equ_to_20(unsigned long long n)&#123; return ((0 == n) ? 1 : n * calc_factorial_less_equ_to_20(n - 1));&#125;int main(void)&#123; while (true) &#123; cout &lt;&lt; \"输入一个不超过20的非负整数：\"; unsigned long long n; cin &gt;&gt; n; if (!cin || n &gt; 20) &#123; // 采用递归实现的阶乘算法最多只能计算20以内的阶乘，否则将导致溢出 break; &#125; cout &lt;&lt; n &lt;&lt; \"的阶乘为：\" &lt;&lt; calc_factorial_less_equ_to_20(n) &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 编写程序，使用函数Fill_array( )将一个double数组的名称和长度作为参数，用户输入double值，如果输入非法，或溢出停止，返回输入多少，Show_array( )将数组名称和长度作为参数，显示该数组，Reverse-array( )将数组的名称和长度作为参数，并将存储在数组中的值的顺序反转。反转数组中除第一个和最后一个元素之外的所有元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;const int Max = 5;double *fill_array(double *pBeg, const double *pEnd)&#123; using namespace std; double temp; int i = 0; while (pBeg &lt; pEnd) &#123; cout &lt;&lt; \"Enter value #\" &lt;&lt; i++ &lt;&lt; \": \"; cin &gt;&gt; temp; if (!cin) // bad input &#123; cin.clear(); while (cin.get() != '\\n') continue; cout &lt;&lt; \"Bad input; input process terminated.\\n\"; break; &#125; else if (temp &lt; 0) break; *pBeg = temp; ++pBeg; // signal to terminate &#125; return pBeg;&#125;// the following function can use, but not alter,// the array whose address is arvoid show_array(const double *pBeg, const double *pEnd)&#123; using namespace std; for (int i = 0; pBeg &lt; pEnd; ++pBeg) &#123; cout &lt;&lt; \"Property #\" &lt;&lt; (i + 1) &lt;&lt; \": $\"; cout &lt;&lt; *pBeg &lt;&lt; endl; &#125;&#125;// multiplies each element of ar[] by rvoid revalue(double r, double *pBeg, const double *pEnd)&#123; while (pBeg &lt; pEnd) &#123; *pBeg *= r; ++pBeg; &#125;&#125;int main()&#123; using namespace std; double properties[Max]; double *pArrEnd = fill_array(properties, properties + Max); show_array(properties, pArrEnd); if (pArrEnd - properties &gt; 0) &#123; cout &lt;&lt; \"Enter revaluation factor: \"; double factor; while (!(cin &gt;&gt; factor)) // bad input &#123; cin.clear(); while (cin.get() != '\\n') continue; cout &lt;&lt; \"Bad input; Please enter a number: \"; &#125; revalue(factor, properties, pArrEnd); show_array(properties, pArrEnd); &#125; cout &lt;&lt; \"Done.\\n\"; cin.get(); cin.get(); return 0;&#125; 修改fill_array( )函数不返回实际读取了多少个数字，而是返回一个指针，该指针指向最后被填充的位置；其他的函数可以将该指针作为第二个参数，以标识数据结尾。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;const int Max = 5;int fill_array(double *pBeg, const double *pEnd)&#123; using namespace std; double temp; int i = 0; while (pBeg &lt; pEnd) &#123; cout &lt;&lt; \"Enter value #\" &lt;&lt; i++ &lt;&lt; \": \"; cin &gt;&gt; temp; if (!cin) // bad input &#123; cin.clear(); while (cin.get() != '\\n') continue; cout &lt;&lt; \"Bad input; input process terminated.\\n\"; break; &#125; else if (temp &lt; 0) break; *pBeg = temp; ++pBeg; // signal to terminate &#125; return i;&#125;// the following function can use, but not alter,// the array whose address is arvoid show_array(const double *pBeg, const double *pEnd)&#123; using namespace std; for (int i = 0; pBeg &lt; pEnd; ++pBeg) &#123; cout &lt;&lt; \"Property #\" &lt;&lt; (i + 1) &lt;&lt; \": $\"; cout &lt;&lt; *pBeg &lt;&lt; endl; &#125;&#125;// multiplies each element of ar[] by rvoid revalue(double r, double *pBeg, const double *pEnd)&#123; while (pBeg &lt; pEnd) &#123; *pBeg *= r; ++pBeg; &#125;&#125;int main()&#123; using namespace std; double properties[Max]; int size = fill_array(properties, properties + Max); show_array(properties, properties + size); if (size &gt; 0) &#123; cout &lt;&lt; \"Enter revaluation factor: \"; double factor; while (!(cin &gt;&gt; factor)) // bad input &#123; cin.clear(); while (cin.get() != '\\n') continue; cout &lt;&lt; \"Bad input; Please enter a number: \"; &#125; revalue(factor, properties, properties + size); show_array(properties, properties + size); &#125; cout &lt;&lt; \"Done.\\n\"; cin.get(); cin.get(); return 0;&#125; 使用const char 数组存储表示季度名称的字符串，并使用double数组存储开支。使用const char 数组存储表示季度名称的字符串，并使用一个结构，该结构只有一个成员——一个用于存储开支的double数组。这种设计与使用array类的基本设计类似.（写两个版本） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//1.#include &lt;iostream&gt;#include &lt;string&gt;// constant dataconst int Seasons = 4;const char *Snames[] = &#123;\"Spring\", \"Summer\", \"Fall\", \"Winter\"&#125;;void fill(double *pa)&#123; using namespace std; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; \"Enter \" &lt;&lt; Snames[i] &lt;&lt; \" expenses: \"; cin &gt;&gt; pa[i]; &#125;&#125;void show(double da[])&#123; using namespace std; double total = 0.0; cout &lt;&lt; \"\\nEXPENSES\\n\"; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; Snames[i] &lt;&lt; \": $\" &lt;&lt; da[i] &lt;&lt; endl; total += da[i]; &#125; cout &lt;&lt; \"Total Expenses: $\" &lt;&lt; total &lt;&lt; endl;&#125;int main()&#123; double expenses[Seasons]; fill(expenses); show(expenses); return 0;&#125;//2.#include &lt;iostream&gt;#include &lt;string&gt;// constant dataconst int Seasons = 4;const char *Snames[] = &#123;\"Spring\", \"Summer\", \"Fall\", \"Winter\"&#125;;struct TData&#123; double arr[Seasons];&#125;;void fill(TData *pData)&#123; using namespace std; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; \"Enter \" &lt;&lt; Snames[i] &lt;&lt; \" expenses: \"; cin &gt;&gt; pData-&gt;arr[i]; &#125;&#125;void show(TData data)&#123; using namespace std; double total = 0.0; cout &lt;&lt; \"\\nEXPENSES\\n\"; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; Snames[i] &lt;&lt; \": $\" &lt;&lt; data.arr[i] &lt;&lt; endl; total += data.arr[i]; &#125; cout &lt;&lt; \"Total Expenses: $\" &lt;&lt; total &lt;&lt; endl;&#125;int main()&#123; TData expenses; fill(&amp;expenses); show(expenses); return 0;&#125; 联系处理数组和结构体函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;const int SLEN = 30;struct student&#123; char fullname[SLEN]; char hobby[SLEN]; int ooplevel;&#125;;// getinfo() has two arguments: a pointer to the first element of// an array of student structures and an int representing the// number of elements of the array. The function solicits and// stores data about students. It terminates input upon filling// the array or upon encountering a blank line for the student// name. The function returns the actual number of array elements// filled.int getinfo(student pa[], int n)&#123; int num_array_elem = n; char tmp[SLEN]; for (unsigned i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; \"输入姓名：\"; cin.getline(tmp, SLEN); bool blank_line = true; for (unsigned j = 0; j &lt; strlen(tmp); ++j) &#123; if (!isspace(tmp[j])) &#123; blank_line = false; break; &#125; &#125; if (blank_line) &#123; num_array_elem = i; break; &#125; strcpy(pa[i].fullname, tmp); cout &lt;&lt; \"输入兴趣：\"; cin.getline(pa[i].hobby, SLEN); cout &lt;&lt; \"输入面向对象程序设计能力的级别：\"; cin &gt;&gt; pa[i].ooplevel; cin.get(); &#125; return (num_array_elem);&#125;// display1() takes a student structure as an argument// and displays its contentsvoid display1(student st)&#123; cout &lt;&lt; st.fullname &lt;&lt; '\\t' &lt;&lt; st.hobby &lt;&lt; '\\t' &lt;&lt; st.ooplevel &lt;&lt; endl;&#125;// display2() takes the address of student structure as an// argument and displays the structure’s contentsvoid display2(const student *ps)&#123; cout &lt;&lt; ps-&gt;fullname &lt;&lt; '\\t' &lt;&lt; ps-&gt;hobby &lt;&lt; '\\t' &lt;&lt; ps-&gt;ooplevel &lt;&lt; endl; ;&#125;// display3() takes the address of the first element of an array// of student structures and the number of array elements as// arguments and displays the contents of the structuresvoid display3(const student pa[], int n)&#123; for (unsigned i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; pa[i].fullname &lt;&lt; '\\t' &lt;&lt; pa[i].hobby &lt;&lt; '\\t' &lt;&lt; pa[i].ooplevel &lt;&lt; endl; &#125;&#125;int main()&#123; cout &lt;&lt; \"输入班级人数：\"; int class_size; cin &gt;&gt; class_size; while (cin.get() != '\\n') continue; student *ptr_stu = new student[class_size]; int entered = getinfo(ptr_stu, class_size); for (int i = 0; i &lt; entered; i++) &#123; display1(ptr_stu[i]); display2(&amp;ptr_stu[i]); &#125; display3(ptr_stu, entered); delete[] ptr_stu; cout &lt;&lt; \"完毕\\n\"; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*calculate( )的函数，它接受两个double值和一个指向函数的指针，而被指向的函数接受两个double参数，并返回一个double值。calculate( )函数的类型也是double，并返回被指向的函数使用calculate( )的两个double参数计算得到的值。例如，假设add( )函数的定义如下：double add (double a,double b)&#123; return a+b;&#125;代码中的函数调用将导致calculate( )把2.5和10.4传递给add( )函数，并返回add( )的返回值（12.9）double q =calculate(2.5, 10.4, add);调用上述两个函数和至少另一个与add( )类似的函数。该程序使用循环来让用户成对地输入数字。对于每对数字，程序都使用calculate( )来调用add( )和至少一个其他的函数.提示：指针数组的声明方式。，double (*pf[3])(double,double);*/#include &lt;iostream&gt;using namespace std;typedef double (*TPfun)(double x, double y);void calculate(double x, double y, TPfun fun[], unsigned num_of_funs)&#123; for (unsigned i = 0; i &lt; num_of_funs; ++i) &#123; cout &lt;&lt; fun[i](x, y) &lt;&lt; endl; &#125;&#125;doubleadd(double x, double y)&#123; cout &lt;&lt; \"加法操作结果：\"; return (x + y);&#125;doublesub(double x, double y)&#123; cout &lt;&lt; \"减法操作结果：\"; return (x - y);&#125;int main(void)&#123; TPfun fun[] = &#123;add, sub&#125;; while (true) &#123; cout &lt;&lt; \"输入两个数：\"; double x, y; cin &gt;&gt; x &gt;&gt; y; if (!cin) &#123; break; &#125; calculate(x, y, fun, sizeof(fun) / sizeof(fun[0])); &#125; cout &lt;&lt; endl; return (0);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/tags/C/"}]},{"title":"C++基础知识02","slug":"C-基础知识02","date":"2019-05-21T06:28:17.000Z","updated":"2019-05-22T06:39:35.398Z","comments":true,"path":"2019/05/21/C-基础知识02/","link":"","permalink":"http://atworking.cn/2019/05/21/C-基础知识02/","excerpt":"第二章：数据结构","text":"第二章：数据结构 简单变量变量名 在名称中只能使用字母字符、数字和下划线（_） 名称的第一个字符不能是数字 区分大写字符与小写字符 不能将C++关键字用作名称 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。 C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制 整型整型就是没有小说部分的数字。char、short、int、long和long long (C++11)每种类型都分有符号版本和无符号版本。检查操作系统中整形的最大长度使用“sizeof”函数。climits头文件常用常量列表： 常量 表示 常量 表示 CHAR_BIT char的位数 CHAR_MAX char的最大值 CHAR_MIN char的最小值 SCHAR_MAX signed char的最大值 SCHAR_MIN signed char的最小值 UCHAR_MAX unsigned char的最大值 SHRT_MAX short的最大值 SHRT_MIN short的最小值 USHRT_MAX unsigned short的最大值 INT_MAX int的最大值 INT_MIN int的最小值 UNIT_MAX unsigned int的最大值 LONG_MAX long的最大值 LONG_MIN long的最小值 ULONG_MAX unsigned long的最大值 LLONG_MAX long long的最大值 LLONG_MIN long long的最小值 ULLONG_MAX unsigned long long的最大值 无符号类型unsigned short/int…假如short表示的范围为−32768到+32767，则无符号版本的表示范围为0-65535，仅当数值不回为负时才使用无符号类型。如果无符号类型为0时再减1，会变成65535，如果超越了限制就会从另一端取值 char类型为存储字母和数值（ASCII码对照表）在默认情况，char不是有符号也不是没符号，一般存储ASCII码 bool类型C++将非零值解释为true，将零解释为false constC++有一种更好的处理符号常量的方法，这种方法就是使用const关键字来修改变量声明和初始化 const int MOnths =12 常量被初始化后，其值就被固定了，编译器将不允许再修改该常量的值两个约定： 将名称的首字母大写，以提醒是个常量 将整个名称大写，使用#define创建常量时通常使用这种约定 浮点数浮点数能够表示带小数部分的数字。C++也有3种浮点类型：float、double和long double注意：1.0也是浮点数 类型转换将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换；表达式中包含不同的类型时，C++将对值进行转换；将参数传递给函数时，C++将对值进行转换.讲一个值赋给取值范围更大的类型不回有什么问题(float-&gt;double int-&gt;long)。将0赋给bool变量时，将被转换为false；而非零值将被转换为true。 潜在数值转换问题： double转换为float:精度（有效数位）降低，值可能超出目标类型的取值范围 浮点类型转换为整型:小数部分丢失，原来的值可能超出目标类型的取值范围 较大的整型转换为较小的整型:原来的值可能超出目标类型的取值范围，通常只复制右边的字节 表达式转换：当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换，首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。自动转换：在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int，这些转换被称为整型提升。传递参数时的转换：传递参数时的类型转换通常由C++函数原型控制，C++将对char和short类型（signed和unsigned）应用整型提升。另外，为保持与传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double。强制类型转换：C++还允许通过强制类型转换机制显式地进行类型转换，强制类型转换不会修改变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值。 （typeName）value 或 typeName(value) 第一种来自C，第二种时C++C++还引入了4个强制类型转换运算符,static_cast&lt;&gt;可用于将值从一种数值类型转换为另一种数值类型,运算符static_cast&lt;&gt;比传统强制类型转换更严格 static_cast（value） C++11的auto声明C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了auto的含义。auto是一个C语言关键字，但很少使用，在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同 auto n = 100 //intauto x = 1.5 //double 问答C++数据类型多样化意义： 可以根据需求选择最合适的数据类型。 声明和初始化 short num1=80unsigned int num2 =999 //无符号unsigned long num3 =300000000 //注意不能使用int C++放溢出 C++没有提供放置超过整形限制的功能，但是可以使用头文件“climits”来获取限制范围，选择合适的类型。 寻找编码的字符 char c = 65；cout&lt;&lt;c&lt;&lt;endl; //Acout.put(char(65));//Acout&lt;&lt;char(65)&lt;&lt;endl;cout&lt;&lt;(char)65&lt;&lt;endl; 强制类型转换(x1,x2位double) int(x1+x2) //先将x1+x2计算，在转换整数int(x1)+int(x2) //先将x1,x2转换为整数，再相加。 代码1.设置一个常量作，用户输入身高，转换为英尺1234567891011121314151617#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const int k_factorFeetToInch = 12; // 1英尺 = 12英寸 int inches; cout &lt;&lt; \"输入身高，__英寸：\"; cin &gt;&gt; inches; //整除 取余 cout &lt;&lt; \"也就\" &lt;&lt; inches / k_factorFeetToInch &lt;&lt; \"英尺又\" &lt;&lt; inches % k_factorFeetToInch &lt;&lt; \"英寸\"; cout &lt;&lt; endl; return (0);&#125; 2.用户(英尺 英寸)方式输入身高，用已磅为单位输入体重，计算体重指数。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; double height, weight, bmi; // 输入身高以英尺和英寸为单位 int feet, inches; cout &lt;&lt; \"输入身高，__英尺又__英寸：\"; cin &gt;&gt; feet &gt;&gt; inches; // 获得以英寸为单位的身高 const int k_factorFeetToInches = 12; // 1英尺 = 12英寸 height = feet * k_factorFeetToInches + inches; // 获得以米为单位的身高 const double k_factorInchesToMeters = 0.0254; // 1英寸 = 0.0254米 height = height * k_factorInchesToMeters; // 输入体重以磅为单位 int pounds; cout &lt;&lt; \"输入以磅为单位的体重：\"; cin &gt;&gt; pounds; // 获得以千克为单位的体重 const double k_factorPoundsToKilograms = 1 / 2.2; // 1磅 = 1/2.2千克 weight = pounds * k_factorPoundsToKilograms; // 计算BMI bmi = weight / (height * height); // 显示BMI cout &lt;&lt; \"BMI：\" &lt;&lt; bmi &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 3.用户输入秒没然后已天、小时、分钟、秒显示此时间段，12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const long k_factorMinuteToSecond = 60; const long k_factorHourToMinute = 60; const long k_factorDayToHour = 24; cout &lt;&lt; \"Enter the number of seconds: \"; long secondsTotal; cin &gt;&gt; secondsTotal; long seconds = secondsTotal % k_factorMinuteToSecond; long minutesTotal = secondsTotal / k_factorMinuteToSecond; long minutes = minutesTotal % k_factorHourToMinute; long hoursTotal = minutesTotal / k_factorHourToMinute; long hours = hoursTotal % k_factorDayToHour; long days = hoursTotal / k_factorDayToHour; cout &lt;&lt; secondsTotal &lt;&lt; \" seconds = \" &lt;&lt; days &lt;&lt; \" days, \" &lt;&lt; hours &lt;&lt; \" hours, \" &lt;&lt; minutes &lt;&lt; \" minutes, \" &lt;&lt; seconds &lt;&lt; \" seconds\"; cout &lt;&lt; endl; return (0);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/tags/C/"}]},{"title":"C++基础知识03","slug":"C-基础知识03","date":"2019-05-21T06:28:17.000Z","updated":"2019-05-22T06:49:25.879Z","comments":true,"path":"2019/05/21/C-基础知识03/","link":"","permalink":"http://atworking.cn/2019/05/21/C-基础知识03/","excerpt":"第三章：复合类型","text":"第三章：复合类型 数组数组（array）是一种数据格式，能够存储多个同类型的值数组声明和索引 声明数组： 存储在每个元素中的值的类型； 数组名； 数组中的元素数。 typeName arrayName[arraySize] 数组元素下标从0开始，arrName[0]第一个元素. 数组初始化 typeName arrayName[arraySize]={xx,xx,xx}arrayName[index] = xxx //赋值arrName[] = {xx,xxx} //长度为2 只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组。可以使用下标分别给数组中的元素赋值。提供的值可以少于数组的元素数目,其他元素已0填充。初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个数 字符串字符串是存储在内存的连续字节中的一系列字符(char数组)，并以空字符（null character）结尾，空字符被写作\\0，其ASCII码为0，用来标记字符串的结尾 字符串初始化 char str[3]={‘h’,’g’,’x’,’\\0’} //字符串char str[3]={‘h’,’g’,’x’,’h’} //非字符串char str[] = “hello” //包括”\\0”的字符串 字符数组初始化为字符串(“”包含原始字符和\\0) 字符串截取只需要在截取的字符数组的索引赋值“\\0” 字符串输入 cin键盘输入字符串，不能使用空格字符(cin使用空格、制表符、和换行符来确定字符串借宿字符，所以只能接收一个单词，并自动在此单词后添加\\0)读取一行在istream中提供了面向行的成员函数“getline()”和“get()”,直到读取换行符。cin.getline()丢弃换行符,参数1：需要存储输入内容的名称，参数2：读取的字符数(10的话只能读取9个字符) cin.getline(name,size) cin.get()将换行符保留在输入序列中， 第一种是参数和getline类似。 第二种不带任何参数的get,可以读取下一个字符(包括换行符)因此可以用它来处理换行符，为读取下一行输入做好准备 123cin.get(name,size) //读取第一行cin.get() //读取换行cin.get(name,size) //读取第二行 第三种有参和无参结合使用. cin,get(name,size).get() 读取空行当getline( )或get( )读取空行时，将设置失效位，接下来的输入将被阻断，可以使用”cin.clear()”恢复使用数字和字符串12345678910cin &gt;&gt; year;char address[90];cin.getline(address,90)---------------------------------当用户输入year时回车直接运行程序，不回让输入address,因为cin.getline获取换行符，就默认没有内容，并不包含换行符，结速。解决办法：cin&gt;&gt;year; //cin.get();//获取换行符或(cin&gt;&gt;year).get() string类C++98标准通过添加string类扩展了C++库，因此现在可以string类型的变量（使用C++的话说是对象）而不是字符数组来存储字符串。注意：使用string类，必须包含头文件string(std空间)123#include&lt;iostream&gt;#include&lt;string&gt;using namespace std 可以使用数组表示法来访问存储在string对象中的字符 可以使用cout来显示string对象 可以使用cin来将键盘输入存储到string对象中 可以使用C-风格字符串来初始化string对象 声明并初始化 string str1 //声明string str2 = “Hello” //声明并初始化 赋值拼接 一个string对象赋给另一个string对象,可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾。使用函数strcpy( )将字符串复制到字符数组中，使用函数strcat( )将字符串附加到字符数组末尾，注意数组大小 strcpy(charr1,charr2) //赋值2到1strcat(charr1,charr2) //追加2到1的末尾 结构初介绍结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。因此创建结构包括两步。首先，定义结构描述—它描述并标记了能够存储在结构中的各种数据类型。然后按描述创建结构变量（结构数据对象）关键字struct定义过结构后可以创建结构类型变量，在C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。在C++中，省略struct不会出错 程序中使用结构 结构的声明一般放在main()函数外面 并用struct修饰，C++不提倡使用外部变量，但是提倡使用外部结构声明。和数组一样，使用由逗号分隔值列表，并将这些值用花括号括起。在该程序中，每个值占一行，但也可以将它们全部放在同一行中。只是应用逗号将它们分开：12345678struct stu&#123; string name; int age;&#125;;int main()&#123; stu stu1=&#123;\"xiaoming\",18&#125;; return 0;&#125; 可将每个结构成员看作是相应类型的变量123stu stu2;stu2.name=\"xiaohong\";stu2.age=20; 可以将结构作为参数传递给函数，也可以让函数返回一个结构。另外，还可以使用赋值运算符（=）将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组 结构数组 可以创建元素为结构的数组，方法和创建基本类型数组完全相同 要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个元素都是结构，因此可以使用结构初始化的方式来提供它的值。因此，最终结果为一个被括在花括号中、用逗号分隔的值列表，其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：1234stu stu1[1]=&#123; &#123;\"xx\",19&#125;, &#123;\"yy\",20&#125;&#125;; 共用体共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型，共用体的句法与结构相似，但含义不同12345union demo&#123; int int_val; long long_val; double double_val;&#125;; 可以使用one4all变量来存储int、long或double，条件是在不同的时间进行（共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度）当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间 枚举C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按严格的限制进行。使用enum的句法与使用结构相似 enum color(red,yellow,green,blue) 让color成为新类型的名称；color被称为枚举 将red、yellow等作为符号常量(枚举量)，它们对应整数值0～3 可以用枚举名来声明这种类型的变量： “color band;”对于枚举，只定义了赋值运算符 设置枚举量 可以使用赋值运算符来显式地设置枚举量的值,指定的值必须是整数,也可以只显式地定义其中一些枚举量的值 enum color(red=1,green=2,blue) //blue=3 指针指针是一个变量，其存储的是值的地址，而不是值本身只需对变量应用地址运算符（&amp;），就可以获得它的位置；例如，如果home是一个变量，则&amp;home是它的地址12int a =10;cout&lt;&lt;&amp;a&lt;&lt;endl; //取取值 处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—指针用于存储值的地址。因此，指针名表示的是地址。*运算符被称为间接值（indirect velue）或解除引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值（这和乘法使用的符号相同。123int num =10;int *p； //指针p = &amp;num; //指针指向num地址 声明和初始化指针 指针声明必须指定指针指向的数据的类型 char* p1,p2; 野指针 在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址 指针和数字 指针不是整型，虽然计算机通常把地址当作整数来处理。从概念上看，指针与整数是截然不同的类型。 new 在C语言中，可以用库函数malloc( )来分配内存；在C++中仍然可以这样做，但C++还有更好的方法—new运算符 程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。下面是一个这样的示例 int * p = new int; new int告诉程序，需要适合存储int的内存。new运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针 为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下 typeName * pointName= new typeName; 对于指针，需要指出的另一点是，new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈（stack）的内存区域中，而new从被称为堆（heap）或自由存储区（free store）的内存区域分配内存 delete释放内存 当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是delete运算符，它使得在使用完内存后，能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放（free）的内存可供程序的其他部分使用。使用delete时，后面要加上指向内存块的指针（这些内存块最初是用new分配的），释放内存，但不会删除指针本身，可以使他指向新的内存用，一定要和new成对用，否则会有内存泄漏危险。123int * p = new int;...delete ps； new来创建动态数组 创建动态数组很容易；只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素数目 int *p = new int[10];dekete [] p; 它指向包含10个int值的内存块中的第1个元素，假设int占4个字节，则将手指沿正确的方向移动4个字节，手指将指向第2个元素。总共有10个元素，这就是手指的移动范围。因此，new语句提供了识别内存块中每个元素所需的全部信息。使用第一个元素p[0],第二个p[1]… 指针和数组 在多数情况下，C++将数组名视为数组的第一个元素的地址，一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。使用new来创建数组以及使用指针来访问不同的元素很简单。只要把指针当作数组名对待即可C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义；这将得到两个元素的间隔。 数组的替代品vector模板类vector类似于string类，也是一种动态数组。您可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的 vector vt(n_elem) //n_elem整型 vector类的功能比数组强大，但付出的代价是效率稍低。如果您需要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便和安全。有鉴于此，C++11新增了模板类array，它也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。要创建array对象，需要包含头文件array。array对象的创建语法与vector稍有不同： array&lt;typeName,n_elem&gt; arr 问答声明一个长度100个short数组 short arr[100]; 使用模版array声明上面数组 array&lt;short,100&gt;arr; 取数组第二个元素的值 arr[1]; char数组转为字符串 char str[]=”hello”; string对象声明和赋值string str=”Hello”; 结构体声明和初始化123456struct fish&#123; char kind[20]; int weight; float length;&#125;;fish petes=&#123;\"trout\",12,22.22&#125; 枚举的声明和指定值 enum response{yes=0,no=1,maybe=2} ted是double变量，声明一个指向ted的指针，并显示此值 double pd = &amp;ted；cout&lt;&lt; pd &lt;&lt;”\\n”; 声明一折指针指向长度10的float数组，并显示第一个和最后一个值 float *pt =arr;cout&lt;&lt;pt[0]&lt;&lt;pt[9]&lt;&lt;”\\n”; 输入正整数长度创建一个动态int数组，分别用new和vector对象 包含iostream 和vector头文件unsigned int size;cin &gt;&gt;size;int *p =new int(size);vector dv(size); （int *）”HelloWorld”打印什么 是有效的，打印字符串的地址，转化为int指针。 给上面结构体动态分配内存，在取出该结构体的成员值 fish *p = new fish;cout&lt;&lt;”输入 kind:”;cin &gt;&gt; p-&gt;kind; 声明一个vector对象和一个array对象，分别包含10个string对象，使用const指定要包含的string对象数1234567#include&lt;string&gt;#include&lt;vector&gt;#include&lt;array&gt;const int Num&#123;10&#125;; //const int Num=10...std::vector&lt;std::string&gt; vstr(Num);std::array&lt;std::string,Num&gt;astr; 代码1.get和getline练习1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; string strFirstname; cout &lt;&lt; \"What is your first name? \"; getline(cin, strFirstname); string strLastname; cout &lt;&lt; \"What is your last name? \"; cin &gt;&gt; strLastname; char chGrade; cout &lt;&lt; \"What letter grade do you deserve? \"; cin &gt;&gt; chGrade; unsigned unAge; cout &lt;&lt; \"What is your age? \"; cin &gt;&gt; unAge; cout &lt;&lt; \"Name: \" &lt;&lt; strLastname &lt;&lt; \", \" &lt;&lt; strFirstname &lt;&lt; endl; cout &lt;&lt; \"Grade: \" &lt;&lt; char(chGrade + 1) &lt;&lt; endl; cout &lt;&lt; \"Age: \" &lt;&lt; unAge &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125;-----------------------------------What is your first name? han gxWhat is your last name? xxWhat letter grade do you deserve? nWhat is your age? 18Name: xx, han gxGrade: oAge: 18 2.要求用户首先输入其名，然后输入其姓；然后程序使用一个逗号和空格将姓和名组合起来，并存储和显示组合结果。请使用string对象和头文件string中的函数。123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; string strFirstname; cout &lt;&lt; \"Enter your first name: \"; cin &gt;&gt; strFirstname; string strLastname; cout &lt;&lt; \"Enter your last name: \"; cin &gt;&gt; strLastname; string strInfo = strLastname + \", \" + strFirstname; cout &lt;&lt; \"Here’s the information in a single string: \" &lt;&lt; strInfo; cout &lt;&lt; endl; return (0);&#125; 3.结构CandyBar包含3个成员。第一个成员存储了糖块的品牌；第二个成员存储糖块的重量（可以有小数）；第三个成员存储了糖块的卡路里含量（整数）。请编写一个程序，声明这个结构，创建一个名为snack的CandyBar变量，并将其成员分别初始化为“Mocha Munch”、2.3和350。初始化应在声明snack时进行。最后，程序显示snack变量的内容。123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;struct TCandyBar&#123; string name; double weight; double calories;&#125;;int main(void)&#123; TCandyBar snack = &#123;\"Mocha Munch\", 2.3, 350&#125;; cout &lt;&lt; snack.name &lt;&lt; \"\\n\" &lt;&lt; snack.weight &lt;&lt; \"\\n\" &lt;&lt; snack.calories &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 4.上面结构体包含三个成员，初始化并显示1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;struct TCandyBar&#123; string name; double weight; double calories;&#125;;int main(void)&#123; TCandyBar snack[] = &#123;&#123;\"Mocha Munch\", 2.3, 350&#125;, &#123;\"阿尔卑斯\", 6.3, 310&#125;, &#123;\"优の良品\", 2.1, 291&#125;&#125;; cout &lt;&lt; snack[0].name &lt;&lt; \"\\t\" &lt;&lt; snack[0].weight &lt;&lt; \"\\t\" &lt;&lt; snack[0].calories &lt;&lt; endl; cout &lt;&lt; snack[1].name &lt;&lt; \"\\t\" &lt;&lt; snack[1].weight &lt;&lt; \"\\t\" &lt;&lt; snack[1].calories &lt;&lt; endl; cout &lt;&lt; snack[2].name &lt;&lt; \"\\t\" &lt;&lt; snack[2].weight &lt;&lt; \"\\t\" &lt;&lt; snack[2].calories &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 5.程序将请求用户输入信息，然后显示这些信息。请使用cin（或它的方法）和cout,使用结构体123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;struct TPizza&#123; string company_name; double diameter; double weight;&#125;;int main(void)&#123; TPizza pizza; cout &lt;&lt; \"输入披萨名：\"; getline(cin, pizza.company_name); cout &lt;&lt; \"输入披萨直径（厘米）：\"; cin &gt;&gt; pizza.diameter; cout &lt;&lt; \"输入披萨重量（克）：\"; cin &gt;&gt; pizza.weight; cout &lt;&lt; pizza.company_name &lt;&lt; \"公司出品直径为\" &lt;&lt; pizza.diameter &lt;&lt; \"厘米重量为\" &lt;&lt; pizza.weight &lt;&lt; \"克的披萨\" &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 6.使用new来为结构分配内存（上方程序），而不是声明一个结构变量12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::cin;using std::endl;using std::string;struct TPizza&#123; string company_name; double diameter; double weight;&#125;;int main (void) &#123; TPizza* p_pizza = new TPizza; cout &lt;&lt; \"输入披萨直径（厘米）：\"; cin &gt;&gt; p_pizza-&gt;diameter; // cin忽略输入流中的空白符（回车符、空格符、制表符），回车符仍保留在输入流中 cout &lt;&lt; \"输入披萨名：\"; cin.get(); // 提取先前留在输入流中的回车符，否则下面的getline()不会等待输入，而直接读取输入流中已有的回车符 getline(cin, p_pizza-&gt;company_name); cout &lt;&lt; \"输入披萨重量（克）：\"; cin &gt;&gt; p_pizza-&gt;weight; cout &lt;&lt; p_pizza-&gt;company_name &lt;&lt; \"公司出品直径为\" &lt;&lt; p_pizza-&gt;diameter &lt;&lt; \"厘米重量为\" &lt;&lt; p_pizza-&gt;weight &lt;&lt; \"克的披萨\" &lt;&lt; endl; delete p_pizza; p_pizza = NULL; //清空指针并把它指向null cout &lt;&lt; endl; return (0);&#125; 7.使用new来动态分配数组，而不是声明一个包含3个元素的CandyBar数组1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;struct TCandyBar&#123; string name; double weight; double calories;&#125;;int main(void)&#123; const unsigned k_candybar_num = 3; TCandyBar *candybar_list = new TCandyBar[k_candybar_num]; candybar_list[0].name = \"Mocha Munch\"; candybar_list[0].weight = 2.3; candybar_list[0].calories = 350; candybar_list[1].name = \"阿尔卑斯\"; candybar_list[1].weight = 6.3; candybar_list[1].calories = 310; candybar_list[2].name = \"优の良品\"; candybar_list[2].weight = 2.1; candybar_list[2].calories = 291; cout &lt;&lt; candybar_list[0].name &lt;&lt; \"\\t\" &lt;&lt; candybar_list[0].weight &lt;&lt; \"\\t\" &lt;&lt; candybar_list[0].calories &lt;&lt; endl; cout &lt;&lt; candybar_list[1].name &lt;&lt; \"\\t\" &lt;&lt; candybar_list[1].weight &lt;&lt; \"\\t\" &lt;&lt; candybar_list[1].calories &lt;&lt; endl; cout &lt;&lt; candybar_list[2].name &lt;&lt; \"\\t\" &lt;&lt; candybar_list[2].weight &lt;&lt; \"\\t\" &lt;&lt; candybar_list[2].calories &lt;&lt; endl; delete[] candybar_list; candybar_list = NULL; cout &lt;&lt; endl; return (0);&#125; 8.编写一个程序，让用户输入三次40码跑的成绩，并显示次数和平均成绩。请使用一个array对象来存储数据1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;using std::array;using std::cin;using std::cout;using std::endl;int main(void)&#123; const unsigned k_times = 3; array&lt;unsigned, k_times&gt; dash_array; cout &lt;&lt; \"输入三次40米短跑成绩：\"; cin &gt;&gt; dash_array[0] &gt;&gt; dash_array[1] &gt;&gt; dash_array[2]; cout &lt;&lt; \"共计输入\" &lt;&lt; k_times &lt;&lt; \"笔短跑成绩，平均分为\" &lt;&lt; (dash_array[0] + dash_array[1] + dash_array[2]) / 3 &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/tags/C/"}]},{"title":"C++基础知识04","slug":"C-基础知识04","date":"2019-05-21T06:28:17.000Z","updated":"2019-05-23T02:03:40.664Z","comments":true,"path":"2019/05/21/C-基础知识04/","link":"","permalink":"http://atworking.cn/2019/05/21/C-基础知识04/","excerpt":"第四章：循环和关系表达式","text":"第四章：循环和关系表达式 for循环 设置初始值 执行测试，看看循环是否应当继续进行 执行循环操作 更新用于测试的值 C++循环设计中包括了这些要素，很容易识别。初始化、测试和更新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表达式，彼此由分号隔开。控制部分后面的语句叫作循环体，只要测试表达式为true，它便被执行 for(initialization;test-expression;update-expression){body} initialization:初始化的值，只执行一次，用其变量计算循环周期test-expression：测试表达式，决定循环体是否被执行。update-expression：更新表达式，在每轮循环结束时执行，此时循环体已经执行完毕1234567891011121314151617181920212223242526/**计算阶乘**/#include&lt;iostream&gt;const int SIZE = 10;int main()&#123; long long factorials[SIZE]; //定义一个数组 factorials[1]=factorials[0]=1LL; // for (int i = 2; i &lt; SIZE; i++) &#123; factorials[i]=i*factorials[i-1]; &#125; for (int i = 0; i &lt; SIZE; i++)&#123; std::cout&lt;&lt;i&lt;&lt;\"! = \"&lt;&lt;factorials[i]&lt;&lt;std::endl; &#125; return 0;&#125;--------------------------------------------0! = 11! = 12! = 23! = 64! = 245! = 1206! = 7207! = 50408! = 403209! = 362880 “++i”与“i++”在一条语句中（即两个分号之间)，++i 被当成(i+1)来计算，i++被当成i来计算对于for循环来说，前++和后++对结果是没有影响，但是执行效率上会不同前++：将值+1,然后返回结果。后++：首先复制一个副本，将其+1，然后将赋值的副本返回(效率略差)。指针的递增/减 *++pt:先将++应用于pt（因为++位于的右边），然后将应用于被递增后的pt ++*pt：先取得pt指向的值，然后将这个值加1 (*pt)++:圆括号指出，首先对指针解除引用，得到值，然后，运算符++将值+1，pt指向不变 *pt++:后缀运算符++的优先级更高，这意味着将运算符用于pt，而不是*pt,因此对指针递增。然而后缀运算符意味着将对原来的地址（&amp;arr[2]）而不是递增后的新地址解除引用，因此*pt++的值为原地址，但该语句执行完毕后，pt的值将为+1的地址。12345678double arr[5]=&#123;11.11,22.22,33.33,44.44,55.55&#125;;double *pt =arr; //11.11++pt; //22.22*++pt; //arr[2],33.33++*pt; //arr[2],34.33(*pt)++; //arr[2],35.33*pt++; //35.33*pt; //44.44 while循环while循环是没有初始化和更新部分的for循环，它只有测试条件和循环体 ` while(test-condition){body} 程序计算圆括号内的测试条件（test-condition）表达式。如果该表达式为true，则执行循环体中的语句。循环获取字符串123456789101112131415161718192021222324#include &lt;iostream&gt;const int SIZE = 20;int main()&#123; using namespace std; char name[SIZE]; cout &lt;&lt; \"输入一个字符串ASCII:\"; cin &gt;&gt; name; int i = 0; while (name[i] != '\\0') //while (name[i]) &#123; cout &lt;&lt; name[i] &lt;&lt; \": \" &lt;&lt; int(name[i]) &lt;&lt; endl; i++; &#125; return 0;&#125;--------------------------------输入一个字符串ASCII:ABCDEFA: 65B: 66C: 67D: 68E: 69F: 70 可以这样修改while行：while (name[i])经过这种修改后，程序的工作方式将不变。这是由于name[i]是常规字符，其值为该字符的编码—非零值或true 延时循环while循环可用于写延时循环，C++库中有一个函数有助于完成这样的工作。这个函数名为clock( )，返回程序开始执行后所用的系统时间。这有两个复杂的问题：首先，clock( )返回时间的单位不一定是秒；其次，该函数的返回类型在某些系统上可能是long，在另一些系统上可能是unsigned long或其他类型。但头文件ctime（较早的实现中为time.h）提供了这些问题的解决方案。首先，它定义了一个符号常量—CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数。因此，将系统时间除以这个值，可以得到秒数。或者将秒数乘以CLOCK_PER_SEC，可以得到以系统时间单位为单位的时间。其次，ctime将clock_t作为clock( )返回类型的别名（参见本章后面的注释“类型别名”），这意味着可以将变量声明为clock_t类型，编译器将把它转换为long、unsigned int或适合系统的其他类型12345678910111213141516#include &lt;iostream&gt;#include &lt;ctime&gt;int main()&#123; using namespace std; cout &lt;&lt; \"输入系统休息时间，秒为单位：\"; float secs; cin &gt;&gt; secs; clock_t delay = secs * CLOCKS_PER_SEC; cout &lt;&lt; \"staring\\a\\n\"; clock_t start = clock(); while (clock() - start &lt; delay) ; cout &lt;&lt; \"over!!! \\a\\n\"; return 0;&#125; do while循环这种循环将首先执行循环体，然后再判定测试表达式，决定是否应继续执行循环。如果条件为false，则循环终止；否则，进入新一轮的执行和测试。这样的循环通常至少执行一次，因为其程序流必须经过循环体后才能到达测试条件 do{body} while(test-expression) 增强for循环C++11新增了一种循环：基于范围（range-based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每个元素执行相同的操作123456789double price[5]=&#123;1.1,2.2,3.3,4.4,5.5&#125;;for (double x : price)&#123; cout&lt;&lt; x &lt;&lt;std::endl; //遍历&#125;-------------------------------------//修改元素值.符号&amp;表明x是一个引用变量for (double &amp;x : price)&#123; X=x*0.8 &#125; 循环文本输入使用cin输入要使用循环来读取来自键盘的文本输入，需要选择某个特殊字符—有时被称为哨兵字符，将其作为停止标记 while(ch != ‘#’) //停止字符为“#” cin.get(char)输入通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符，成员函数cin.get(ch)读取输入中的下一个字符（即使它是空格），并将其赋给变量ch12345678//此程序不完美：一个值放在ch变量中，这意味着将修改该变量的值。//在C语言中，要修改变量的值，必须将变量的地址传递给函数char ch;cin.get(ch); //获取第一个输入的字符while(ch!='#')&#123; cout&lt;&lt;ch; cin.get(ch); //使用cin.get &#125; 文件尾的条件文件尾（EOF）。C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序，检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过成员函数eof( )来查看eofbit是否被设置；如果检测到EOF，则cin.eof( )将返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1，则fail( )成员函数返回true，否则返回false。注意，eof( )和fail( )方法报告最近读取的结果；也就是说，它们在事后报告，而不是预先报告。因此应将cin.eof( )或cin.fail( )测试放在读取后，程序清单5.18中的设计体现了这一点。它使用的是fail( )，而不是eof( )，因为前者可用于更多的实现中。whindows “Ctrl+Z和Enter”mac “Ctrl+D” while(cin.fail()==false) //检测EOF cin.clear( )方法可能清除EOF标记，使输入继续进行 cin.get(ch)和cin.get()区别传递输入字符的方式：cin.get(ch)-&gt;赋给参数chcin.get()-&gt;将函数返回值赋给ch 用于字符输入时函数的返回值cin.get(ch)-&gt;istream对象（执行bool转换后为true）cin.get()-&gt;int类型的字符编码 到达EOF时函数的返回值cin.get(ch)-&gt;istream对象（执行bool转换后为false）cin.get()-&gt;EOF 二维数组和嵌套循环初始化：1234int arrTwo[2][3]=&#123; //两行三列 ｛1,2,3｝， ｛4,5,6｝&#125;； 使用二维数组：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;const int X = 4;const int Y = 3;int main()&#123; using namespace std; /* //char数组的数组 char city[X][25]=&#123; \"BJ\", \"HN\", \"GZ\", \"TJ\" &#125;; */ //指针数组初始化为一组字符串常量 const char *city[X] = &#123;\"BJ\", \"HN\", \"GZ\", \"TJ\"&#125;; int temp[Y][X] = &#123; &#123;96, 97, 98,99&#125;, &#123;88, 89, 87,88&#125;, &#123;71, 72, 73,70&#125;&#125;; cout &lt;&lt; \"-------------------------------\\n\"; for (int i = 0; i &lt; X; ++i) &#123; cout &lt;&lt; city[i] &lt;&lt; \":\\t\"; for (int j = 0; j &lt; Y; j++) &#123; cout &lt;&lt; temp[j][i] &lt;&lt; \"\\t\"; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;---------------------------BJ: 96 88 71HN: 97 89 72GZ: 98 87 73TJ: 99 88 70 程序使用了一个嵌套循环。这一次，循环的顺序相反，将列循环放在外面，将行循环放在内面,它还采用了C++常用的做法，将一个指针数组初始化为一组字符串常量,也就是说，将city声明为一个char指针数组。这使得每个元素（如city [0]）都是一个char指针，可被初始化为一个字符串的地址。如果希望字符串是可修改的，则应省略限定符const 问答入口循环和出口循环 for和while属于入口循环，先判断条件。do while是出口循环，至少执行一次循环体。 int j=5; while(++j &lt;9){ cout&lt;&lt;j++&lt;&lt;endl;}打印什么 6 8 打印1、2、4、8、16、32、64的for循环，每轮循环都将计数变量的值乘以2。 for(int num=1; num&lt;=64; num*=2) int x =(1,024)是否有效 有效，表示1和024，用逗号连接，值为右侧表达式的值。24，八进制20 int y =1,024是否有效 有效,y=1 在查看输入方面，cin &gt;&gt;ch同cin.get(ch)和ch=cin.get( )有什么不同 cin&gt;&gt;ch将跳过空格、换行符和制表符，其他读取这些符号 代码1.用户输入两个整数，该程序计算这两个整数之间的整数和1234567891011121314151617181920212223242526#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; int nLowerBound, nUpperBound; cout &lt;&lt; \"输入区间：\"; cin &gt;&gt; nLowerBound &gt;&gt; nUpperBound; int nSum = 0; for (int i = nLowerBound; i &lt;= nUpperBound; ++i) &#123; nSum += i; &#125; cout &lt;&lt; \"[\" &lt;&lt; nLowerBound &lt;&lt; \", \" &lt;&lt; nUpperBound &lt;&lt; \"]区间总和为\" &lt;&lt; nSum; cout &lt;&lt; endl; return (0);&#125;--------------------------------输入区间：2 9[2, 9]区间总和为44 2.使用array对象（而不是数组）和long double（而不是long long）编写计算100!的值123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;array&gt;using std::array;using std::cin;using std::cout;using std::endl;int main(void)&#123; const unsigned k_uSize = 101; array&lt;long double, k_uSize&gt; factorials; factorials[1] = factorials[0] = 1.0L; for (unsigned i = 2; i &lt; k_uSize; ++i) &#123; factorials[i] = i * factorials[i - 1]; &#125; for (unsigned i = 0; i &lt; k_uSize; ++i) &#123; cout &lt;&lt; i &lt;&lt; \"! = \" &lt;&lt; factorials[i] &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 3.编写一个要求用户输入数字的程序。每次输入后，程序都将报告到目前为止，所有输入的累计和。当用户输入0时，程序结束12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const int k_nEndFlag = 0; int nSum = 0; int nTmp; cout &lt;&lt; \"输入数字：\"; do &#123; cin &gt;&gt; nTmp; nSum += nTmp; &#125; while (k_nEndFlag != nTmp); cout &lt;&lt; \"总和为：\" &lt;&lt; nSum; cout &lt;&lt; endl; return (0);&#125;--------------------输入数字：120总和为：3 4.Daphne以10%的单利投资了100美元。也就是说，每一年的利润都是投资额的10%，即每年10美元：(利息 = 0.10×原始存款)而Cleo以5%的复利投资了100美元。也就是说，利息是当前存款（包括获得的利息）的5%，：(利息 = 0.05×当前存款)Cleo在第一年投资100美元的盈利是5%—得到了105美元。下一年的盈利是105美元的5%—即5.25美元，依此类推。请编写一个程序，计算多少年后，Cleo的投资价值才能超过Daphne的投资价值，并显示此时两个人的投资价值。1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const double k_dSimpleInterest = 0.1; const double k_dCompoundInterest = 0.05; const double k_dDaphneBase = 100; const double k_dCleoBase = 100; unsigned uYears = 0; double dDaphneTotal = k_dDaphneBase, dCleoTotal = k_dCleoBase; do &#123; dDaphneTotal += k_dDaphneBase * k_dSimpleInterest; dCleoTotal += dCleoTotal * k_dCompoundInterest; ++uYears; cout &lt;&lt; uYears &lt;&lt; \": \" &lt;&lt; dDaphneTotal &lt;&lt; \"\\t\" &lt;&lt; dCleoTotal &lt;&lt; endl; &#125; while (dDaphneTotal &gt;= dCleoTotal); cout &lt;&lt; endl; cout &lt;&lt; uYears &lt;&lt; \"年后，\" &lt;&lt; \"Cleo的财富将超过Daphne，前者将达到$\" &lt;&lt; dCleoTotal &lt;&lt; \"、后者$\" &lt;&lt; dDaphneTotal &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 5.销售一本书，输入全年中每个月的销售量（图书数量，而不是销售额）。程序通过循环，使用初始化为月份字符串的char *数组（或string对象数组）逐月进行提示，并将输入的数据储存在一个int数组中。然后，程序计算数组中各元素的总数，并报告这一年的销售情况。1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; unsigned lstMonthlySales[12]; const string k_months[] = &#123;\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"&#125;; cout &lt;&lt; \"输入每月销售量。\" &lt;&lt; endl; for (int i = 0; i &lt; 12; ++i) &#123; cout &lt;&lt; k_months[i] &lt;&lt; \"：\"; cin &gt;&gt; lstMonthlySales[i]; &#125; unsigned uSum = 0; for (int i = 0; i &lt; 12; ++i) &#123; uSum += lstMonthlySales[i]; &#125; cout &lt;&lt; \"全年销售总量\" &lt;&lt; uSum &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 6.使用一个二维数组来存储输入—3年中每个月的销售量。程序将报告每年销售量以及三年的总销售量123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; unsigned lstMonthlySales[3][12]; const string k_months[] = &#123;\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"&#125;; for (int i = 0; i &lt; 3; ++i) &#123; cout &lt;&lt; \"输入第\" &lt;&lt; i + 1 &lt;&lt; \"年每月销售量。\" &lt;&lt; endl; for (int j = 0; j &lt; 12; ++j) &#123; cout &lt;&lt; k_months[j] &lt;&lt; \"：\"; cin &gt;&gt; lstMonthlySales[i][j]; &#125; cout &lt;&lt; endl; &#125; for (int i = 0; i &lt; 3; ++i) &#123; unsigned uSum = 0; for (int j = 0; j &lt; 12; ++j) &#123; uSum += lstMonthlySales[i][j]; &#125; cout &lt;&lt; \"第\" &lt;&lt; i + 1 &lt;&lt; \"年销售总量\" &lt;&lt; uSum &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 7.设计一个名为car的结构，用它存储下述有关汽车的信息：生产商（存储在字符数组或string对象中的字符串）、生产年份（整数）。编写一个程序，向用户询问有多少辆汽车。随后，程序使用new来创建一个由相应数量的car结构组成的动态数组。接下来，程序提示用户输入每辆车的生产商（可能由多个单词组成）和年份信息。请注意，这需要特别小心，因为它将交替读取数值和字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;struct TCar&#123; string strMaker; unsigned uBulitYear;&#125;;int main(void)&#123; cout &lt;&lt; \"How many cars do you wish to catalog? \"; //unsigned int unsigned uCatalogNum; cin &gt;&gt; uCatalogNum; cin.get(); // 指针类型 new一个内存空间 TCar *pCarsLst = new TCar[uCatalogNum]; for (unsigned i = 0; i &lt; uCatalogNum; ++i) &#123; cout &lt;&lt; \"Car #\" &lt;&lt; i + 1 &lt;&lt; \": \" &lt;&lt; endl; cout &lt;&lt; \"Please enter the make: \"; getline(cin, pCarsLst[i].strMaker); //不包含换行符 cout &lt;&lt; \"Please enter the year made: \"; cin &gt;&gt; pCarsLst[i].uBulitYear; cin.get(); //获取换行符 &#125; cout &lt;&lt; \"Here is your collection: \" &lt;&lt; endl; for (unsigned i = 0; i &lt; uCatalogNum; ++i) &#123; //数组本身就是指针，默认指向第一个元素 cout &lt;&lt; pCarsLst[i].uBulitYear &lt;&lt; \" \" &lt;&lt; pCarsLst[i].strMaker &lt;&lt; endl; &#125; //清空指针指向并指向空的位置 delete[] pCarsLst; pCarsLst = NULL; cout &lt;&lt; endl; return (0);&#125; 8.编写一个程序，它使用一个char数组和循环来每次读取一个单词，直到用户输入done为止。随后，该程序指出用户输入了多少个单词（不包括done在内）12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; cout &lt;&lt; \"Enter words (to stop, type the word done): \"; //只读 不能做修改 //const char *:char类型指针变量 //const k_szDone: 常量变量 const char *const k_szDone = \"done\"; const unsigned k_uSize = 64; int cntWord = -1; //计数器. // 字符串 char word[k_uSize]; do &#123; ++cntWord; cin &gt;&gt; word; &#125; while (strcmp(k_szDone, word)); //比较两字符串是否相等 cout &lt;&lt; \"You entered a total of \" &lt;&lt; cntWord &lt;&lt; \" words.\" &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125;---------------------Enter words (to stop, type the word done): hello hh hgx done hanYou entered a total of 3 words. 9.重写上面程序，使用string和关系运算符12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; cout &lt;&lt; \"Enter words (to stop, type the word done): \"; //常量字符串(char数组) const string k_strDone = \"done\"; int cntWord = -1; string strWord; do &#123; ++cntWord; cin &gt;&gt; strWord; &#125; while (k_strDone != strWord); cout &lt;&lt; \"You entered a total of \" &lt;&lt; cntWord &lt;&lt; \" words.\" &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 10.编写一个使用嵌套循环的程序，要求用户输入一个值，指出要显示多少行。然后，程序将显示相应行数的星号，其中第一行包括一个星号，第二行包括两个星号，依此类推。没哟星星用句号填充12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const char k_ch1 = '.'; const char k_ch2 = '*'; cout &lt;&lt; \"Enter number of rows: \"; unsigned uRows; cin &gt;&gt; uRows; // 分配内存 输入大小的平方(输出的是正方形) char *pCharLst = new char[uRows * uRows]; for (unsigned i = 0; i &lt; uRows; ++i) &#123; for (unsigned j = 0; j &lt; uRows - i - 1; ++j) &#123; pCharLst[i * uRows + j] = k_ch1; &#125; for (unsigned j = uRows - i - 1; j &lt; uRows; ++j) &#123; pCharLst[i * uRows + j] = k_ch2; &#125; &#125; for (unsigned i = 0; i &lt; uRows * uRows; ++i) &#123; cout &lt;&lt; pCharLst[i]; if (0 == (i + 1) % uRows) &#123; cout &lt;&lt; endl; &#125; &#125; delete[] pCharLst; pCharLst = NULL; cout &lt;&lt; endl; return (0);&#125;----------------------------------.....*....**...***..****.***********","categories":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/tags/C/"}]},{"title":"C++基础知识05","slug":"C-基础知识05","date":"2019-05-21T06:28:17.000Z","updated":"2019-05-28T12:23:34.439Z","comments":true,"path":"2019/05/21/C-基础知识05/","link":"","permalink":"http://atworking.cn/2019/05/21/C-基础知识05/","excerpt":"第五章：分支语句和逻辑运算","text":"第五章：分支语句和逻辑运算 if语句if有两种格式：if和if else，如果测试条件为true，则if语句将引导程序执行语句或语句块；如果条件是false，程序将跳过这条语句或语句块 if(测试语句){body}if(测试语句){body}else{body} 逻辑表达式C++提供了3种逻辑运算符，分别是逻辑OR（||）、逻辑AND（&amp;&amp;）和逻辑NOT（!） 逻辑OR运算符：||将两个表达式组合在一起。如果原来表达式中的任何一个或全部都为true（或非零），则得到的表达式的值为true；否则，表达式的值为false ，C++规定，||运算符是个顺序点（sequence point）。也是说，先修改左侧的值，再对右侧的值进行判定（C++11的说法是，运算符左边的子表达式先于右边的子表达式） 逻辑AND运算符：&amp;&amp;逻辑AND运算符（&amp;&amp;），也是将两个表达式组合成一个表达式。仅当原来的两个表达式都为true时，得到的表达式的值才为true，&amp;&amp;运算符也是顺序点，因此将首先判定左侧，并且在右侧被判定之前产生所有的副作用。如果左侧为false，则整个逻辑表达式必定为false，在这种情况下，C++将不会再对右侧进行判定 逻辑NOT运算符：!!运算符将它后面的表达式的真值取反。也是说，如果expression为true，则!expression是false；如果expression为false，则!expression是true。更准确地说，如果expression为true或非零，则!expression为false。 其他表示方式标识符and、or和not都是C++保留字，这意味着不能将它们用作变量名等。它们不是关键字，因为它们都是已有语言特性的另一种表示方式。另外，它们并不是C语言中的保留字，但C语言程序可以将它们用作运算符，只要在程序中包含了头文件iso646.h。C++不要求使用头文件. 字符函数库cctypeC++从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype（老式的风格中为ctype.h）中定义的. 函数名 返回值 isalnum() 如果参数是字母数字，即字母或数字，该函数返回true isalpha() 如果参数是字母，该函数返回true iscntrl() 如果参数是控制字符，该函数返回true isdigit() 如果参数是数字（0～9），该函数返回true isgraph() 如果参数是除空格之外的打印字符，该函数返回true islower() 如果参数是小写字母，该函数返回true isprint() 如果参数是打印字符（包括空格），该函数返回true ispunct() 如果参数是标点符号，该函数返回true isspace() 如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符或者垂直制表符，该函数返回true isupper() 如果参数是大写字母，该函数返回true isxdigit() 如果参数是十六进制数字，即0～9、a～f或A～F，该函数返回 tolower() 如果参数是大写字符，则返回其小写，否则返回该参数 toupper() 如果参数是小写字符，则返回其大写，否则返回该参数 运算符”?:”C++有一个常被用来代替if else语句的运算符，这个运算符被称为条件运算符（?:），它是C++中唯一一个需要3个操作数的运算符 表达式1 ? 表达式2 : 表达式3 如果expression1为true，则整个条件表达式的值为expression2的值；否则，整个表达式的值为expression3的值。 switch语句C++的switch语句就像指路牌，告诉计算机接下来应执行哪行代码。执行到switch语句时，程序将跳到使用integer-expression的值标记的那一行，integer-expression必须是一个结果为整数值的表达式。另外，每个标签都必须是整数常量表达式。最常见的标签是int或char常量，也可以是枚举量。如果integer-expression不与任何标签匹配，则程序将跳到标签为default的那一行。Default标签是可选的，如果被省略，而又没有匹配的标签，则程序将跳到switch后面的语句处执行 switch语句与Pascal等语言中类似的语句之间存在重大的差别。C++中的case标签只是行标签，而不是选项之间的界线。也是说，程序跳到switch中特定代码行后，将依次执行之后的所有语句，除非有明确的其他指示。程序不会在执行到下一个case处自动停止，要让程序执行完一组特定语句后停止，必须使用break语句。这将导致程序跳到switch后面的语句处执行 将枚举作为标签通常，cin无法识别枚举类型（它不知道程序员是如何定义它们的），因此该程序要求用户选择选项时输入一个整数。当switch语句将int值和枚举量标签进行比较时，将枚举量提升为int。另外，在while循环测试条件中，也会将枚举量提升为int类型。 123456789101112131415enum (red,orange,yellow)int main()&#123; int code; cin &gt;&gt; code; while (code &gt;=red &amp;&amp; code &lt;= yellow)&#123; switch (code)&#123; case red; cout &lt;&lt; \"this is red \\n\"; break; case orange; cout &lt;&lt; \"this is orange \\n\"; break; case yellow; cout &lt;&lt; \"this is yellow \\n\"; break; &#125; cout &lt;&lt; \"no cloro\"; cin &gt;&gt;code &#125; return 0;&#125; switch 和 if elseswitch语句和if else语句都允许程序从选项中进行选择。相比之下，if else更通用。switch并不是为处理取值范围而设计的。switch语句中的每一个case标签都必须是一个单独的值。另外，这个值必须是整数（包括char），因此switch无法处理浮点测试。另外case标签值还必须是常量。如果选项涉及取值范围、浮点测试或两个变量的比较，则应使用if else语句.如果所有的选项都可以使用整数常量来标识，则可以使用switch语句或if else语句。由于switch语句是专门为这种情况设计的，因此，如果选项超过两个，则就代码长度和执行速度而言，switch语句的效率更高。 break和continuebreak和continue语句都使程序能够跳过部分代码。可以在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处执行。continue语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657\\#include &lt;iostream&gt;const int AirSize = 80;int main()&#123;​ using namespace *std*;​ char line[AirSize];​ int spaces = 0;​ cout &lt;&lt; \"Enter a line of text: \\n\";​ cin.get(line, AirSize);​ cout &lt;&lt; \"Complete line:\\n\"​ &lt;&lt; line &lt;&lt; endl;​ for (int i = 0; line[i] != '\\0'; i++)​ &#123;​ cout &lt;&lt; line[i];​ if (line[i] == '.')​ break;​ if (line[i] != ' ')​ continue;​ spaces++;​ &#125;​ cout &lt;&lt; \"\\n\"​ &lt;&lt; spaces &lt;&lt; \" spaces\\n\";​ cout &lt;&lt; \"Done.\\n\";​ return 0;&#125;----------------------------------------Enter a line of text:Hello world, everyone i love you. or you name?Complete line:Hello world, everyone i love you. or you name?Hello world, everyone i love you.5 spacesDone. 该程序让用户输入一行文本。循环将回显每个字符，如果该字符为句点，则使用break结束循环。这表明，可以在某种条件为true时，使用break来结束循环。接下来，程序计算空格数，但不计算其他字符。当字符不为空格时，循环使用continue语句跳过计数部分。continue语句导致该程序跳过循环体的剩余部分，但不会跳过循环的更新表达式。在for循环中，continue语句使程序直接跳到更新表达式处，然后跳到测试表达式处。然而，对于while循环来说，continue将使程序直接跳到测试表达式处，因此while循环体中位于continue之后的更新表达式都将被跳过。 goto语句：和C语言一样，C++也有goto语句。下面的语句将跳到使用paris:作为标签的位置： goto paris; 在大多数情况下（有些人认为，在任何情况下），使用goto语句不好，而应使用结构化控制语句（如if else、switch、continue等）来控制程序的流程 读取数字的循环当程序接受一系列数字时(cin &gt;&gt;n);如果用户输入一个单词，需要对这个输入单词进行处理。程序必须先重置cin，然后才能删除错误输入 1．重置cin以接受新的输入 2．删除错误输入。 3．提示用户再输入 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;const int MAX = 5;int main()&#123; using namespace std; int golf[MAX]; cout &lt;&lt; \"Plese enter you scores.\\n\"; cout &lt;&lt; \"you must enter \" &lt;&lt; MAX &lt;&lt; \" rounds.\\n\"; int i; for (i = 0; i &lt; MAX; i++) &#123; cout &lt;&lt; \"round #\" &lt;&lt; i + 1 &lt;&lt; \" : \"; while (!(cin &gt;&gt; golf[i])) //当输入字母时 为true进入循环 &#123; cin.clear(); //reset input while (cin.get() != '\\n') continue; cout &lt;&lt; \"please enter a num: \"; &#125; &#125; cout &lt;&lt; \"end!\\n\"; return 0;&#125;-----------------------------------------------Plese enter you scores.you must enter 5 rounds.round #1 : 10round #2 : aaplease enter a num: 11round #3 : 33 简单的文件输入\\出C++使得将读取键盘输入和在屏幕上显示输出（统称为控制台输入/输出）的技巧用于文件输入/输出（文件I/O），这里只介绍简单的文本文件I/O。 文本I/O和文本文件使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据——文本数据，cin对象负责将文本转换为其他类型。 写入到文本文件中 必须包含头文件fstream。 头文件fstream定义了一个用于处理输出的ofstream类。 需要声明一个或多个ofstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。 必须指明名称空间std；例如，为引用元素ofstream，必须使用编译指令using或前缀std::。 需要将ofstream对象与文件关联起来。为此，方法之一是使用open( )方法。 使用完文件后，应使用方法close( )将其关闭。 可结合使用ofstream对象和运算符&lt;&lt;来输出各种类型的数据。 虽然头文件iostream提供了一个预先定义好的名为cout的ostream对象，但您必须声明自己的ofstream对象，为其命名，并将其同文件关联起来。 ofstream outFile; ofstream fout; outFile.open(“xx.txt”); char filename[50]; cin &gt;&gt;filename; fout.open(filename); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;fstream&gt; //ioint main()&#123; using namespace std; char automobile[50]; int year; double a_price; double b_price; ofstream outFile; //创建文件对象 outFile.open(\"info.txt\"); cout &lt;&lt; \"Enter the make and model of automobile: \"; cin.getline(automobile, 50); cout &lt;&lt; \"enter the model year: \"; cin &gt;&gt; year; cout &lt;&lt; \"enter the price: \"; cin &gt;&gt; a_price; b_price = 0.5 * a_price; //display infomation on screen with cout cout &lt;&lt; fixed; cout.precision(2); cout.setf(ios_base::showpoint); cout &lt;&lt; \"make and model: \" &lt;&lt; automobile &lt;&lt; endl; cout &lt;&lt; \"year: \" &lt;&lt; year &lt;&lt; endl; cout &lt;&lt; \"was asking $\" &lt;&lt; a_price &lt;&lt; endl; cout &lt;&lt; \"Now asking $\" &lt;&lt; b_price &lt;&lt; endl; //using outFIle outFile &lt;&lt; fixed; outFile.precision(2); outFile.setf(ios_base::showpoint); outFile &lt;&lt; \"make and model: \" &lt;&lt; automobile &lt;&lt; endl; outFile &lt;&lt; \"year: \" &lt;&lt; year &lt;&lt; endl; outFile &lt;&lt; \"was asking $\" &lt;&lt; a_price &lt;&lt; endl; outFile &lt;&lt; \"Now asking $\" &lt;&lt; b_price &lt;&lt; endl; outFile.close(); return 0;&#125;----------------------------------------------------Enter the make and model of automobile: hello hanenter the model year: 1991enter the price: 100make and model: hello hanyear: 1991was asking $100.00Now asking $50.00---------------------------------------------------info.txt:make and model: hello hanyear: 1991was asking $100.00Now asking $50.00 ofstream对象后，便可以使用方法open( )将该对象特定文件关联起来,程序使用完该文件后，应该将其关闭,方法close( )不需要使用文件名作为参数，这是因为outFile已经同特定的文件关联起来。如果您忘记关闭文件，程序正常终止时将自动关闭它,outFile可使用cout可使用的任何方法。它不但能够使用运算符&lt;&lt;，还可以使用各种格式化方法，如setf( )和precision( )。这些方法只影响调用它们的对象. open()方法：如果路径已经存在文件时，open( )将首先截断该文件，即将其长度截短到零——丢其原有的内容，然后将新的输出加入到该文件中 读取文本文件 必须包含头文件fstream。 头文件fstream定义了一个用于处理输入的ifstream类。 需要声明一个或多个ifstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则 必须指明名称空间std；例如，为引用元素ifstream，必须使用编译指令using或前缀std::。 需要将ifstream对象与文件关联起来。为此，方法之一是使用open( )方法。 使用完文件后，应使用close( )方法将其关闭。 可结合使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据。 可以使用ifstream对象和get( )方法来读取一个字符，使用ifstream对象和getline( )来读取一行字符。 可以结合使用ifstream和eof( )、fail( )等方法来判断输入是否成功。 ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false 虽然头文件iostream提供了一个预先定义好的名为cin的istream对象，但您必须声明自己的ifstream对象，为其命名，并将其同文件关联起来 ifstream inFile; ifstream fin; inFile.open(“xxx.txt”); char filename[50]; cin &gt;&gt; filename; fin.open(filename); 声明一个ifstream对象并将其同文件关联起来后，便可以像使用cin那样使用它。所有可用于cin的操作和方法都可用于ifstream对象,如果试图打开一个不存在的文件用于输入，这种错误将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功打开的首先方法是使用方法is_open( )， 1234inFile.open(\"info.txt\");if (!inFile.is_open())&#123; exit(EXIT_FAILURE)&#125; 如果文件没有被打开，表达式!inFile.isopen( )将为true。函数exit( )的原型是在头文件cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值EXIT_FAILURE。函数exit( )终止程序，s_open( )是C++中相对较新的内容。如果读者的编译器不支持它，可使用较老的方法good( )来代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;fstream&gt; //io#include &lt;cstdlib&gt; //exit()const int SIZE = 60;int main()&#123; using namespace std; char filename[SIZE]; ifstream inFile; cout &lt;&lt; \"enter filename:\"; cin.getline(filename, SIZE); inFile.open(filename); if (!inFile.is_open()) &#123; cout &lt;&lt; \"Could not open file: \" &lt;&lt; filename &lt;&lt; endl; exit(EXIT_FAILURE); &#125; double value; double sum = 0.0; int count = 0; inFile &gt;&gt; value; //get first value while (inFile.good()) //while input good and not at EOF &#123; ++count; sum += value; inFile &gt;&gt; value; &#125; if (inFile.eof()) &#123; cout &lt;&lt; \"End of file reached.\\n\"; &#125; else if (inFile.fail()) &#123; cout &lt;&lt; \"input terminated by data mismatch.\\n\"; &#125; else &#123; cout &lt;&lt; \"input terminated for unknow reason.\\n\"; &#125; if (count == 0) &#123; cout &lt;&lt; \"No data processed.\\n\"; &#125; else &#123; cout &lt;&lt; \"iteam read: \" &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; \"sum: \" &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; \"Average: \" &lt;&lt; sum / count &lt;&lt; endl; &#125; inFile.close(); return 0;&#125;-----------------------------------------------------enter filename:test.txtEnd of file reached.iteam read: 11sum: 187Average: 17-----------------------------------------------------目录下必须又test.txt:18 19 18.5 13.5 1416 19.5 20 18 12 18.517.5 读取文件时，有几点需要检查。首先，程序读取文件时不应超过EOF。如果最后一次读取数据时遇到EOF，方法eof( )将返回true。其次，程序可能遇到类型不匹配的情况,如果最后一次读取操作中发生了类型不匹配的情况，方法fail( )将返回true（如果遇到了EOF，该方法也将返回true）最后，可能出现意外的问题，如文件受损或硬件故障。如果最后一次读取文件时发生了这样的问题，方法bad( )将返回true。不要分别检查这些情况，一种更简单的方法是使用good( )方法，该方法在没有发生任何错误时返回true.infile.eof(),infile.fail()由于eof( )只能判断是否到达EOF，而fail( )可用于检查EOF和类型不匹配，因此上述代码首先判断是否到达EOF。这样，如果执行到了else if测试，便可排除EOF，因此，如果fail( )返回true，便可断定导致循环终止的原因是类型不匹配.方法good( )指出最后一次读取输入的操作是否成功，这一点至关重要。这意味着应该在执行读取输入的操作后，立刻应用这种测试。为此，一种标准方法是，在循环之前（首次执行循环测试前）放置一条输入语句，并在循环的末尾（下次执行循环测试之前）放置另一条输入语句”infile&gt;&gt;value” 可以精简while(infile &gt;&gt;value) 问答 if if 和if else有什么区别： if else 效率更好，if成立 else不在判断，而俩if，都会判断一遍。 ch为字符，++ch 和ch+1区别 值相同，但是++ch类型蔚char，可以作为字符打印，ch+1值蔚int,只能作为int打印 创建一个条件表达式，其值为变量的绝对值 (x&lt;0) ? -x:x / (x&gt;=0)x:-x 程序输出什么12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main()&#123; char ch; int ct1, ct2; ct1 = ct2 = 0; while ((ch = cin.get()) != '$') &#123; cout &lt;&lt; ch; ct1++; if (ch = '$') &#123; ct2++; &#125; cout &lt;&lt; ch; &#125; cout &lt;&lt; \"ct1 = \" &lt;&lt; ct1 &lt;&lt; \"; ct2 = \" &lt;&lt; ct2 &lt;&lt; \"\\n\"; return 0;&#125;--------------------输入内容------------------------hi!send $10 or $20 now-------------------输出结果-------------------------hi!h$i$!$$send $10 or $20 nows$e$n$d$ $ct1 = 9; ct2 = 9 由于ch=’$’ 而不是ch==’$’’ 因此输出结果会出现上面效果 重写 不要使用break 和continue1234567891011121314151617 int line = 0; char ch; while (cin.get(ch)) &#123; if (ch == 'Q') break; if (ch != '\\n') continue; line++; &#125;---------------重写如下------------------int line = 0;char ch;while(cin.get(ch)&amp;&amp; ch!='Q')&#123; if (ch=='\\n') line++;&#125; 代码 编写一个程序，读取键盘输入，直到遇到@符号为止，并回显输入（数字除外），同时将大写字符转换为小写，将小写字符转换为大写（别忘了cctype函数系列） 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cctype&gt;int main(void)&#123; using namespace std; const char k_flagEnd = '@'; char ch; while (cin &gt;&gt; ch &amp;&amp; k_flagEnd != ch) &#123; if (isdigit(ch)) &#123; continue; &#125; if (islower(ch)) &#123; ch = (char)toupper(ch); &#125; else if (isupper(ch)) &#123; ch = (char)tolower(ch); &#125; else &#123; ; // nop! &#125; cout &lt;&lt; ch; &#125; cout &lt;&lt; endl; return (0);&#125; 编写一个程序，最多将10个donation值读入到一个double数组中。程序遇到非数字输入时将结束输入，并报告这些数字的平均值以及数组中有多少个数字大于平均值。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;int main(void)&#123; using namespace std; const unsigned k_size = 10; double arrDonation[k_size]; double dSum = 0; unsigned cntDonation = 0; while (cntDonation &lt; k_size &amp;&amp; cin &gt;&gt; arrDonation[cntDonation]) &#123; dSum += arrDonation[cntDonation++]; &#125; double dAverage = dSum / cntDonation; unsigned cntLargerAverage = 0; for (unsigned i = 0; i &lt; k_size; ++i) &#123; if (arrDonation[i] &gt; dAverage) &#123; ++cntLargerAverage; &#125; &#125; cout &lt;&lt; \"平均值为\" &lt;&lt; dAverage &lt;&lt; \"，超过平均值的有\" &lt;&lt; cntLargerAverage &lt;&lt; \"个。\" &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 使用switch编写一个菜单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;int main(void)&#123; using namespace std; cout &lt;&lt; \"Please enter one of the following choices: \" &lt;&lt; endl; cout &lt;&lt; \"c) carnivore\\t\" &lt;&lt; \"p) pianist\" &lt;&lt; endl; cout &lt;&lt; \"t) tree\\t\\t\" &lt;&lt; \"g) game\" &lt;&lt; endl; char ch; while (cin &gt;&gt; ch) &#123; switch (ch) &#123; case 'c': &#123; cout &lt;&lt; \"A dog is a carnivore. \" &lt;&lt; endl; &#125; break; case 'p': &#123; cout &lt;&lt; \"Lang Lang is a pianist. \" &lt;&lt; endl; &#125; break; case 't': &#123; cout &lt;&lt; \"A maple is a tree.\" &lt;&lt; endl; &#125; break; case 'g': &#123; cout &lt;&lt; \"Red alert is a game. \" &lt;&lt; endl; &#125; break; default: cout &lt;&lt; \"Please enter a c, p, t, or g: \"; break; &#125; &#125; cout &lt;&lt; endl; return (0);&#125; 编写一个程序，使用真实姓名、头衔、秘密姓名或成员偏好来列出成员，该程序创建一个由结构组成的小型数组，并将其初始化为适当的值。另外，该程序使用一个循环，让用户在下面的选项中进行选择 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;const unsigned gk_size = 64;enum TPreference&#123; FULLNAME, TITLE, BOPNAME&#125;;struct TBop&#123; char szFullname[gk_size]; // real name char szTitle[gk_size]; // job title char szBopname[gk_size]; // secret BOP name TPreference preference;&#125;;int main(void)&#123; using namespace std; TBop lstBops[] = &#123;&#123;\"Yang Yang\", \"chinamobile\", \"yangyang.gnu\", TITLE&#125;, &#123;\"xiao wang\", \"microsoft\", \"xiaowang\", BOPNAME&#125;, &#123;\"xiao liu\", \"IBM\", \"xiaoliu\", FULLNAME&#125;, &#123;\"xiao zhang\", \"Huawei\", \"xiaozhang\", TITLE&#125;&#125;; bool bDisplay = true; while (bDisplay) &#123; cout &lt;&lt; \"Benevolent Order of Programmers Report\" &lt;&lt; endl; cout &lt;&lt; \"a. display by name\" &lt;&lt; \"\\t\" &lt;&lt; \"b. display by title\" &lt;&lt; endl; cout &lt;&lt; \"c. display by bopname\" &lt;&lt; \"\\t\" &lt;&lt; \"d. display by preference\" &lt;&lt; endl; cout &lt;&lt; \"q. quit\" &lt;&lt; endl; char chAction; if (!(cin &gt;&gt; chAction)) &#123; bDisplay = false; break; &#125; switch (chAction) &#123; case 'a': &#123; for (const auto &amp;e : lstBops) &#123; cout &lt;&lt; e.szFullname &lt;&lt; endl; &#125;; &#125; break; case 'b': &#123; for (const auto &amp;e : lstBops) &#123; cout &lt;&lt; e.szTitle &lt;&lt; endl; &#125;; &#125; break; case 'c': &#123; for (const auto &amp;e : lstBops) &#123; cout &lt;&lt; e.szBopname &lt;&lt; endl; &#125;; &#125; break; case 'd': &#123; for (const auto &amp;e : lstBops) &#123; if (FULLNAME == e.preference) &#123; cout &lt;&lt; e.szFullname &lt;&lt; endl; &#125; else if (TITLE == e.preference) &#123; cout &lt;&lt; e.szTitle &lt;&lt; endl; &#125; else if (BOPNAME == e.preference) &#123; cout &lt;&lt; e.szBopname &lt;&lt; endl; &#125; else &#123; ; &#125; &#125; &#125; break; case 'q': &#123; cout &lt;&lt; \"Bye! \" &lt;&lt; endl; bDisplay = false; &#125; break; default: &#123; cout &lt;&lt; \"Error! \" &lt;&lt; endl; &#125; break; &#125; &#125; cout &lt;&lt; endl; return (0);&#125; 计算税收，5000下不收 5001-1500:10%；15001-35000：15%；35000+：20%,当用户输入负数或非数字时，循环结束 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;int main(void)&#123; using namespace std; // |-----|----------|--------------------|-----... // 0% (5K) 10% (1.5W) 15% (3.5W) 20% double tvarp; while (cin &gt;&gt; tvarp &amp;&amp; tvarp &gt;= 0) &#123; double arrFourSection[4] = &#123;5000, 10000, 20000&#125;; if (tvarp &lt;= 5000) &#123; arrFourSection[0] = tvarp; arrFourSection[1] = arrFourSection[2] = arrFourSection[3] = 0; &#125; else if ((tvarp -= 5000) &lt;= 10000) &#123; arrFourSection[1] = tvarp; arrFourSection[2] = arrFourSection[3] = 0; &#125; else if ((tvarp -= 10000) &lt;= 20000) &#123; arrFourSection[2] = tvarp; arrFourSection[3] = 0; &#125; else &#123; arrFourSection[3] = tvarp - 20000; &#125; cout &lt;&lt; \"税收明细如下：\" &lt;&lt; arrFourSection[0] &lt;&lt; \" * 0% + \" &lt;&lt; arrFourSection[1] &lt;&lt; \" * 10% + \" &lt;&lt; arrFourSection[2] &lt;&lt; \" * 15% + \" &lt;&lt; arrFourSection[3] &lt;&lt; \" * 20% \" &lt;&lt; \" = \" &lt;&lt; arrFourSection[0] * 0 + arrFourSection[1] * 0.1 + arrFourSection[2] * 0.15 + arrFourSection[3] * 0.2 &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 用户输入捐献者数目，然后要求用户输入每一个捐献者的姓名和款项。这些信息被储存在一个动态分配的结构数组中。每个结构有两个成员：用来储存姓名的字符数组（或string对象）和用来存储款项的double成员。读取所有的数据后，程序将显示所有捐款超过10000的捐款者的姓名及其捐款数额。该列表前应包含一个标题，指出下面的捐款者是重要捐款人（Grand Patrons）。然后，程序将列出其他的捐款者，该列表要以Patrons开头。如果某种类别没有捐款者，则程序将打印单词“none”。该程序只显示这两种类别，而不进行排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct TDonor&#123; string name; double amount;&#125;;int main(void)&#123; cout &lt;&lt; \"输入捐赠人数：\"; unsigned num_donor; cin &gt;&gt; num_donor; TDonor *const p_donor = new TDonor[num_donor]; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; cout &lt;&lt; \"输入捐赠人姓名：\"; cin &gt;&gt; p_donor[i].name; cout &lt;&lt; \"输入捐赠金额：\"; cin &gt;&gt; p_donor[i].amount; &#125; cout &lt;&lt; \"荣誉捐赠者：\" &lt;&lt; endl; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; if (p_donor[i].amount &gt;= 10000) &#123; cout &lt;&lt; p_donor[i].name &lt;&lt; endl; &#125; &#125; cout &lt;&lt; \"普通捐赠者：\" &lt;&lt; endl; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; if (p_donor[i].amount &lt; 10000) &#123; cout &lt;&lt; p_donor[i].name &lt;&lt; endl; &#125; &#125; delete[] p_donor; cout &lt;&lt; endl; return (0);&#125; 编写一个程序，它每次读取一个单词，直到用户只输入q。然后，该程序指出有多少个单词以元音打头，有多少个单词以辅音打头，还有多少个单词不属于这两类。为此，方法之一是，使用isalpha( )来区分以字母和其他字符打头的单词，然后对于通过了isalpha( )测试的单词，使用if或switch语句来确定哪些以元音打头 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;int main(void)&#123; using namespace std; unsigned cntVowels = 0, cntConsonants = 0, cntOthers = 0; cout &lt;&lt; \"输入单词，字母q结束：\"; string word; while (cin &gt;&gt; word &amp;&amp; \"q\" != word) &#123; char &amp;first_char = word[0]; if (!isalpha(first_char)) &#123; ++cntOthers; &#125; else if ('a' == first_char || 'A' == first_char || 'e' == first_char || 'E' == first_char || 'i' == first_char || 'I' == first_char || 'o' == first_char || 'O' == first_char || 'u' == first_char || 'U' == first_char) &#123; ++cntVowels; &#125; else &#123; ++cntConsonants; &#125; &#125; cout &lt;&lt; \"元音开头的单词\" &lt;&lt; cntVowels &lt;&lt; \"个、辅音单词\" &lt;&lt; cntConsonants &lt;&lt; \"个、其他\" &lt;&lt; cntOthers &lt;&lt; \"个\" &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 编写一个程序，它打开一个文件文件，逐个字符地读取该文件，直到到达文件末尾，然后指出该文件中包含多少个字符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;const int SIZE = 60;int main()&#123; //-----打开测试文件U6p8test.txt- using namespace std; char filename[SIZE]; ifstream inFile; cout &lt;&lt; \"Enter name of data file: \"; cin.getline(filename, SIZE); inFile.open(filename); if (!inFile.is_open()) &#123; cout &lt;&lt; \"Could not open the file \" &lt;&lt; filename &lt;&lt; endl; cout &lt;&lt; \"Program terminating.\\n\"; exit(EXIT_FAILURE); &#125; //开始读取数据 char value; int count = 0; inFile &gt;&gt; value; while (inFile.good()) &#123; ++count; inFile &gt;&gt; value; &#125; //文件读取末尾 if (inFile.eof()) cout &lt;&lt; \"End of file reached.\\n\"; else if (inFile.fail()) cout &lt;&lt; \"Input terminated by data mismatch.\\n\"; else cout &lt;&lt; \"Input terminated for unknown reason.\\n\"; if (count == 0) cout &lt;&lt; \"No data processed.\\n\"; else &#123; cout &lt;&lt; \"chars: \" &lt;&lt; count &lt;&lt; endl; &#125; inFile.close(); return 0;&#125; 完成编程练习6，但从文件中读取所需的信息。该文件的第一项应为捐款人数，余下的内容应为成对的行。在每一对中，第一行为捐款人姓名，第二行为捐款数额 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;struct TDonor&#123; string name; double amount;&#125;;int main(void)&#123; ifstream ifs(\"contributor_(for_linux).txt\"); unsigned num_donor; ifs &gt;&gt; num_donor; TDonor *const p_donor = new TDonor[num_donor]; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; ifs.get(); getline(ifs, p_donor[i].name); ifs &gt;&gt; p_donor[i].amount; &#125; cout &lt;&lt; \"荣誉捐赠者：\" &lt;&lt; endl; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; if (p_donor[i].amount &gt;= 10000) &#123; cout &lt;&lt; p_donor[i].name &lt;&lt; endl; &#125; &#125; cout &lt;&lt; \"普通捐赠者：\" &lt;&lt; endl; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; if (p_donor[i].amount &lt; 10000) &#123; cout &lt;&lt; p_donor[i].name &lt;&lt; endl; &#125; &#125; delete[] p_donor; cout &lt;&lt; endl; return (0);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/tags/C/"}]},{"title":"C++基础知识01","slug":"C-基础知识01","date":"2019-05-21T02:06:43.000Z","updated":"2019-05-22T06:39:56.255Z","comments":true,"path":"2019/05/21/C-基础知识01/","link":"","permalink":"http://atworking.cn/2019/05/21/C-基础知识01/","excerpt":"第一章：基础了解","text":"第一章：基础了解 基础知识：C++程序的基础模块叫什么 函数 #include什么作用 会在编译之前，使用iostream文件内容替换该编译指令 using namespace std什么作用 使程序可以使用std名称空间的定义，放在函数定义之前，让所有函数都能使用名称空间std中所有元素放在指定函数定义中，让该函数能够使用在特定的函数中使用using std::cout，让该函数能够使用指定元素cout。完全不使用编译指令，而使用命名空间元素时 使用 1std::cout&lt;&lt;\"Hello\"&lt;&lt;std:endl 打印hello并开始新的一行 12cout &lt;&lt; \"hello\\n\"; cout &lt;&lt; \"hello\" &lt;&lt; endl; 创建变量 类型 变量名 1int num 赋值 变量=值 键盘输入赋值 1cin &gt;&gt; num 打印拼接1cout &lt;&lt; \"num value is\"&lt;&lt; num &lt;&lt; \"，is int type\" &lt;&lt;endl 函数定义 返回值类型 函数名 （参数）在没有函数返回值的情况下可以不使用“return”，也可以使用“return;” 123int froop(double t); //函数传入double类型，返回int类型值void noreturn(int n); //传入一个int参数，没有返回值int prune(void); //没有参数传入，但是返回一个int类型值 代码：1.HelloWorld123456789//中文如果乱码将文件改成GBK编码#include &lt;iostream&gt;int main(void)&#123; using std::cout; using std::endl; cout &lt;&lt; \"我是小星星,河南人！！\" &lt;&lt;endl; cout &lt;&lt; endl; return(0);&#125; 2.用户键盘输入一个整形，并计算返回12345678910#include &lt;iostream&gt;int main(void)&#123; using namespace std; //命名空间 double inputNum; //定义一个双精度变量 cout &lt;&lt; \"输入一个double类型的数：\" &lt;&lt; endl; cin &gt;&gt; inputNum; //获取输入的值并赋给定义的变量 cout &lt;&lt; \"计算乘2减3的结果:\" &lt;&lt;inputNum * 2 -3 &lt;&lt; \"。结束计算\" &lt;&lt; endl; cout &lt;&lt; endl; return(0);&#125; 3.用户自定义函数12345678910111213141516171819202122232425#include &lt;iostream&gt;//命名空间using std::cin;using std::cout;using std::endl;//定义函数1void print_one(void)&#123; cout &lt;&lt; \"函数一\" &lt;&lt; endl;&#125;//定义函数2void print_two(void)&#123; cout &lt;&lt; \"函数二\" &lt;&lt; endl;&#125;int main(void)&#123; //调用函数 print_one(); print_two(); cout &lt;&lt; endl; return (0);&#125; 4.用户输入年两，计算包含多少月12345678910111213141516#include &lt;iostream&gt;int main (void) &#123; using std::cout; using std::cin; using std::endl; int age; cout &lt;&lt; \"Enter your age: \"; cin &gt;&gt; age; cout &lt;&lt; \"Your age in months is \" &lt;&lt; age * 12 &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 5.使用自定义函数完成华氏度和摄氏度的转换 华氏温度 = 1.8 * 摄氏度 + 32 12345678910111213141516#include &lt;iostream&gt;double cal(double celsius)&#123; return (1.8 * celsius + 32.0);&#125;int main(void)&#123; using namespace std; double celsius; cout &lt;&lt; \"请输入当前温度(摄氏度)：\"; cin &gt;&gt; celsius; cout &lt;&lt; \"当前华氏度：\" &lt;&lt; cal(celsius) &lt;&lt; \"华氏度\"; cout &lt;&lt; endl; return (0);&#125; 6.用户输入小时和分钟并格式化 xx:xx1234567891011121314151617181920#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;void fmtTime(int hour, int minute)&#123; cout &lt;&lt; \"当前时间：(\" &lt;&lt; hour &lt;&lt; \":\" &lt;&lt; minute &lt;&lt; \").\" &lt;&lt; endl;&#125;int main(void)&#123; int hour, minute; cout &lt;&lt; \"请输入当前小时:\"; cin &gt;&gt; hour; cout &lt;&lt; \"请输入分钟：\"; cin &gt;&gt; minute; fmtTime(hour, minute); cout &lt;&lt; endl; return (0);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://atworking.cn/tags/C/"}]},{"title":"VSCODE-C++环境配置","slug":"VSCODE-C-环境配置","date":"2019-05-20T02:51:28.000Z","updated":"2019-05-27T12:27:42.217Z","comments":true,"path":"2019/05/20/VSCODE-C-环境配置/","link":"","permalink":"http://atworking.cn/2019/05/20/VSCODE-C-环境配置/","excerpt":"PicGO图床快捷方式： 粘贴图片路径上传：CTRL+ALT+U 选择图片文件上传: CTRL+ALT+E 从输入框上传图片：CTRL+ALT+O","text":"PicGO图床快捷方式： 粘贴图片路径上传：CTRL+ALT+U 选择图片文件上传: CTRL+ALT+E 从输入框上传图片：CTRL+ALT+O VSCODE下载:VSCODE下载地址 mingw64离线包下载：mingw64离线包下载： 环境配置：mingw64\\bin配置到path变量 vscode 安装插件! 选择c++源码文件夹,新建.vscode目录 配置“launch.json” 1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(gdb) Launch\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.exe\",// 将要进行调试的程序的路径 \"args\": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \"stopAtEntry\": false, // 设为true时程序将暂停在程序入口处，一般设置为false \"cwd\": \"$&#123;workspaceRoot&#125;\", // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 \"environment\": [], \"externalConsole\": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:\\\\mingw64\\\\bin\\\\gdb.exe\", //注意这里要与MinGw的路径对应 \"setupCommands\": [ &#123; \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true &#125; ], \"preLaunchTask\": \"g++\", // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &#125; ]&#125; 配置tasks.json 1234567891011121314151617&#123; \"version\": \"2.0.0\", \"command\": \"g++\", \"args\": [\"-g\",\"$&#123;file&#125;\",\"-o\",\"$&#123;fileBasenameNoExtension&#125;.exe\"], // 编译命令参数 \"problemMatcher\": &#123; \"owner\": \"cpp\", \"fileLocation\": [\"relative\", \"$&#123;workspaceRoot&#125;\"], \"pattern\": &#123; \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 &#125; &#125; &#125; 配置”settings.json” 12345678&#123; \"files.exclude\": &#123; \"**/.classpath\": true, \"**/.project\": true, \"**/.settings\": true, \"**/.factorypath\": true &#125;&#125;","categories":[{"name":"VSCODE","slug":"VSCODE","permalink":"http://atworking.cn/categories/VSCODE/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://atworking.cn/tags/IDE/"},{"name":"VSCODE","slug":"VSCODE","permalink":"http://atworking.cn/tags/VSCODE/"}]}]}