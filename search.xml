<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git和GitHub]]></title>
    <url>%2F2019%2F06%2F17%2FGit%E5%92%8CGitHub%2F</url>
    <content type="text"><![CDATA[PicGO图床快捷方式： 粘贴图片路径上传：CTRL+ALT+U 选择图片文件上传: CTRL+ALT+E 从输入框上传图片：CTRL+ALT+O Git和GitHubGit基本使用：Git的工作域： 下载git: https://git-scm.com 初始化： git config –global user.name “用户名” git config –global user.email “邮箱” clone代码到本地仓库 git clone git@github.com:hanguoxing/xxx.git git clone https://github.com/hanguoxing/xxx.git 先本地仓库添加当前修改 git add . //所有修改 git add -p //某个文件 查看状态 git status 显示帮助信息 git help -g 回到远程仓库状态(抛弃本地所有修改，回到远程仓库状态) git fetch –all &amp;&amp; git reset –hard origin/master 重设第一个commit(将所有修改重放回工作区，并清空所有commit) git update -ref -d HEAD 输出工作区和暂存区的区别 git diff 显示本地仓库中任意两个commit文件变动 git diff 显示暂存区和最近版本不同 git diff –cached 显示工作区、暂存区和本地最近的版本(commit)的不同 git diff HEAD 快速切换分支 git checkout - 删除已合并到master的分支 git branch –merged master | grep -v ‘^*| master’ | xargs -n 1 git branch -d 显示本地分支关联远程仓库的清空 git branch -vv 关联远程分支 git branch -u origin/branchName 推送到远程仓库 git push origin/branchName -u 列出所有远程分支 git branch -r 列出本地和远程分支 git branch -a 创建并切换到本地分支 git checkout -b 创建并切换远程分支 git checkout -b origin/ 删除本地分支 git branch -d 删除远程分支 git push origin –delete git push origin : 重命名本地分支 git branch -m 查看标签 git tag 显示当前分支最近的tag git describe –tags –abbrev=0 创建本地标签 git tag 默认tag是在最近一次commit，执行commit打tag git tag -a -m “描述” 推送本地标签到远程仓库 git push origin 一次推送所有标签，同步到远程仓库 git push origin –tags 删除本地标签 git tag -d 删除远程标签(需要先删除本地标签) git push origin :refs/tags/ 切回某个标签 git checkout -b branch_name tag_name 放弃工作区的修改 git checkout 放弃所有修改 git checkout . 恢复删除的文件 git rev-list -n 1 HEAD – &lt;file_path&gt; #得到 deleting_commit git checkout &lt;deleting_commit&gt;^ – &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态 以新增一个commit的方式还原某一个commit的修改 git revert 回到某个commit的状态， 并删除后面的commit git reset #默认就是-mixed参数。git reset –mixed HEAD^ #回退至上个版本， 它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配， 但是也到此为止。 工作区不会被更改。git reset –soft HEAD~3 #回退至三个版本之前， 只回退了commit的信息， 暂存区和工作区与回退之前保持一致。 如果还要提交， 直接commit即可git reset –hard #彻底回退到指定commit-id的状态， 暂存区和工作区也会变为指定commit-id版本的内容 修改上一个commit的描述 git commit –amend 查看commit历史 git log 查看某段代码谁写的 git blame 显示本地更新过HEAD的git命令记录 git reflog 修改作者名 git commit –amend –author=’Author Name &#x65;&#x6d;&#97;&#x69;&#x6c;&#x40;&#x61;&#x64;&#x64;&#114;&#x65;&#x73;&#115;&#46;&#x63;&#111;&#x6d;‘ 修改远程仓库url git remote set-url origin 增加远程仓库 git remote add origin 列出所有远程仓库 git remote 查看两个星期内的改动 git whatchanged –since=’2 weeks ago’ 把A分支的某一个commit， 放到B分支上 git checkout &amp;&amp; git cherry-pick 给git命令起别名 简化操作 git config –global alias.st statu # git status 简化 git st 存储当前修改但不执行提交commit git stash 保存当前状态， 包括untracked的文件(新建文件) git stash -u 显示所有的stashes git stash list 回到某个stash的状态 git stash apply \&lt;stash@{n}> 回到最后一个stash的状态， 并删除这个stash git stash pop 删除所有的stash git stash clear 从stash中拿出某个文件的修改 git checkout &lt;stash@{n}&gt; – 显示所有的tracked文件 git ls-files -t 显示所有untracked文件 git ls-files –others 显示所有忽略的文件 git ls-files –others -i –exclude-standard 强制删除untracked的文件 不会影响tracked的文件的改动 git clean -f 强制删除untracked的目录 git clean -df 显示commit历史(简化) git log –pretty=oneline –graph –decorate –all 把某个分支导出成一个文件 git bundle create 从包中导入分支 ,新建一个分支， 分支内容就是上面 git bundle create 命令导出的内容 git clone repo.bundle -b 执行rebase之前自动stash git rebase –autostash 从远程仓库根据ID， 拉下某一状态， 到本地分支 git fetch origin pull//head: 详细展示一行中的修改 git diff –word-diff 清除gitignore文件中记录的文件 git clean -X -f 展示忽略的文件 git status –ignored commit历史中显示Branch1有的， 但是Branch2没有commit git log Branch1 ^Branch2 在commit log中显示GPG签名 git log –show-signature 显示所有的alias和配置 git config –global –list (全局) # local为当前 删除全局配置 git config –global –unset 新建并切换到新分支上， 同时这个分支没有任何commit git checkout –orphan 展示任意分支某一文件的内容 git show : clone下来指定的单一分支 git clone -b –single-branch https://github.com/user/repo.git 忽略某个文件改动 关闭 track 指定文件的改动， 也就是 Git 将不会在记录这个文件的改动 git update-index –assume-unchanged path/to/file 恢复 track 指定文件的改动 git update-index –no-assume-unchanged path/to/file 忽略文件的权限变化 git config core.fileMode false 以最后提交的顺序列出所有Git分支 (最新放到嘴上) git for-each-ref –sort=-committerdate –format=’%(refname:short)’ refs/heads/ 在commit log中查找相关内容 （查找字段） git log –all –grep=’ 把暂存区的指定file放到工作区中 git reset 强制推送 git push -f Git 的基本命令config:git config –list : 显示所有配置信息 git config –global user.name :配置全局用户名,”global”改为”local”表示配置局部用户名 help:git help :显示一些常见的命令和意义 init:git init : 在本地初始化一个git仓库 clone:git clone xxxx: 从远程服务器克隆一个仓库到本地 add：git add README: 添加工作目录的文件到暂存区 status:git status: 显示工作树的状态 Untracked files : 未被跟踪的文件，表示目录新增的文件 Changes not staged for commit: 工作目录修改文件，未添加到暂存区 Changes to be committed: 添加到暂存区文件，等待提交 commit：git commit -m “提交消息”：提交暂存区的文件，并写提交消息 git commit -a -m “提交消息”：跳过暂存区，字节提交工作目录中所有改变的文件，但不能提交本地目录新增的文件 git commit –author=xxx -m “提交消息”:重写提交作者并提交暂存区 git commit –date=12.13.2019T09:00:00 -m “提交消息”：重写提交日期 git commit –amend -m “提交消息”: 通过创建一个新的提交，替换当前分支的前端(在最新一次提交的基础上进行提交)。 reset:git reset: 将暂存区的我所有文件充值到当前分支的HEAD git reset files: 将暂存区的指定文件终止到指定的commit,没有commit 默认是HEAD。 git reset [–hard|soft|mixed|merge|keep] []:将当前分支重设到指定的commit,并根据mode有可能更新账户安全和工作目录。 hard：充值暂存区和工作目录到指定提交,删除commit之后的所有提交，并将head指向该提交(慎用) soft: 暂存区和工作目录不会变化，仅仅删除commit之后的所有提交并将head指定该提交 mixed: 默认方式，充值暂存区到指定提交，删除commit之后的所有提交并将head指向该提交 merge|keep: 基本不用 HEAD是指向当前分支引用的指针，该指针指向在该分支上的最后一个提交的指针。这意味着HEAD将是下一个创建的提交的父亲。一般来说，把你的HEAD作为你最后一次提交的快照，是最简单的。HEAD~1表示HEAD的前一次提交，HEAD~2表示HEAD的前两次提交，以此类推 rm:git rm files : 删除工作目录的文件 git rm -f files：强制删除工作目录的文件，不做更新检查 git rm –cached files: 删除暂存区的文件 mv:git mv oldfile newfile :重命名文件 git mv files dir: 移动文件到指定目录 git mv -f oldfile newfile: 强制为文件重命名，即使目标文件已经存在 git mv -f files dir: 强制移动文件到指定目录 branch:git branch: 查看所有分支 git branch branchname: 创建分支 git branch branchname ：以特定提交为基础创建分支 git branch -d branchname: 删除分支 git branch -D branchname: 强制删除分支 git branch -m [oldname] newname: 移动或者删除分支 git branch -M [oldname] newname: 强制移动或删除分支 git branch -r: 列出所有被跟踪的远程分支 git branch -r -d branchnam: 删除被跟踪的远程分支 git branch -a : 列出所有本地分支与被跟踪的远程分支 checkoutgit checkout ：检查本地仓库分支与远程仓库分支差异 git checkout branchname|tagname: 切换分支或切换到指定tag,同名优先切换分支 git checkout tags/tagname: 切换到指定的tag git checkout -b branchname: 新建分支并切换到该分支 git checkout -B branchname: 强制新建分支并切换到该分支 merge:git merge branchname -m “提交消息”：将指定分支合并到当前分支(带提交操作)，-m “提交消息”可省略 git merge : 将指定提交合并到当前分支上 git merge branchname1 branchname2: 将分支1和分支2合并到当前分支 git merge –squash branchname: 将指定分支上的所有修改放入当前分支工作目录与暂存区，不提交 git merge no–squash branchname: 将指定分支上所有修改放入当前分支工作目录与暂存区，并提交 mergetool:git mergetool: 在”merge”命令执行之后出现冲突时执行该命令，用来解决合并的冲突，冲突解决完后不要忘了提交。 stash:git stash：储藏工作目录和暂存区的状态到堆栈中 git stash pop [stash@{id}]: 恢复到指定储藏状态，默认最近一次的状态，并从对战中移除该储藏 git stash apply [stash@{id}]: 恢复到指定的储藏状态 git stash drop [stash@{id}]: 从对战中移除指定储藏 git stash list: 显示所有储藏信息 tag:git tag: 列出所有标签 git tag -l ‘v1.*’: 列出更符合一定条件的标签 git tag tagname: 新建标签 fetch:git fetch: 下载远程仓库”origin”到本地 git fetch remoterepository: 下载指定远程仓库到本地‘ git fetch remoterepository branchname: 下载指定远程仓库指定分支到本地 pull:git pull remoterepository branchname[:localbranch]：拉取指定远程仓库指定分支到本地仓库指定分支（默认是当前分支） push：git push remoterepository localbranch[:remotebranch] [–tags]：推送本地仓库指定分支到远程仓库指定分支（默认是与本地分支同名的远程分支），默认是不推送标签到远程仓库的，加上--tags就会推送标签 remote:git remote： 查看所有与本地仓库关联的远程仓库 git remoter -V: 查看所有与本地仓库关联的远程仓库，并显示url git remote add remote-name remote-url: 添加与本地仓库关联的远程仓库 git remote rename oldname newname: 为远程仓库重命名 git remote remove remote-name: 移除远程仓库 submodule:git submodule add repository-url dir: 添加仓库到指定目录，是指成为本仓库的子模块 git submodule init: 初始化子模块 git submodule update: 更新子模块 子模块是本仓库依赖的另一个仓库，但是我们不会对所依赖的仓库（子模块）进行修改，只会在必要的时候进行更新操作。 show:git show [-times]: 显示最近times次，默认一次，提交所有对象信息 log：git log : 查看提交记录 git log –all: 查看所有提交记录 git log –oneline: 查看提交记录，并以oneline形式显示。 git log -p -times: 表示查看最近times次提交改变的内容 git log -stat [-times]: 查看最近times次(默认所有)提交记录，并显示差异分析 diff:git diff: 查看工作目录和暂存区的差异 git diff –cached []: 查看暂存区和指定提交(默认HEAD)的差异 git diff : 查看工作目录和指定提交的差异 git diff : 查看两次提交的差异 git diff branchname: 查看工作目录与指定分支的差异 git diff branchname branchname: 查看两个分支的差异 上面的所有操作后面都可以加上-- dir表示查看该目录下面的差异，在后面加上&gt;patchname.patch表示将差异生成补丁，patchname是补丁的名字 shortlog:git shortlog: 显示总提交次数与每次提交的提交消息 describe:git describe [|]: 查看指定提交或指定标间的注解标签信息 git describe –tags [|]: 查看指定提交或者指定标签的标签信息 git describe –all [|]: 查看指定提交或指定标签的引用信息 reflog:git reflog: 显示所有提交、下拉、推送、与切换分支操作 git reflog –all: 显示所有提交、下拉、推送操作 apply:git apply [–index|–cached] patchname.patch: 将暂存区与工作目录或暂存区(默认工作目录)打补丁 git apply –reverse|-R pathname.patch: 方向打补丁 git apply –reject pathname.patch: 打不定，将没有冲突的文件合并，将有冲突的文件标记出来，并生成对应的.rej文件 cherry-pick:git cherry-pick : 将另一个分支上面的指定提交应用到当前分支上 git cherry-pick banchname: 将指定分支上的最后一次提交应用到当前分支上。 rebase:git rebase branchname: 将指定分支上所有修改引用到当前分支 git rebase branchname branchname: 将第一个指定分支上所有修改引用到第二个分支上 在rebase 加上-i 会提供交付的变基操作 revert:git revert : 恢复一个指定提交 bisect：git bisect start: 开始二分查找 git bisect bad []: 设置指定提交为bad git bisect good []: 设置指定提交为good 输入了上面三个命令后就会自动开始二分查找，我们之后只需要标记当前提交时bad还是good就行了，如果当前找的的提交时bad就输入git bisect bad，否则输入git bisect good直到找到有bug的提交 blame:git blame filename: 查看指定文件的所有操作者 grep:git grep keys: 在工作目录中所有文件中搜索keys git grep –cached keys: 在暂存区中所有文件搜索keys Github四大提供代码托管服务的网站：Google Code，CodePlex，SourceForge，Github。 在git上配置github 下载git并初始化 git config –global user.name “” git config –global user.email “” 生成密钥(win默认在user/用户/.ssh) ssh-keygen -t rsa -C “github邮箱” 打开github-&gt;settings-&gt;ssh，配置id_rsa内容 git与github简单操作 clone项目到本地 git clone 仓库的git地址 在本地初始化一个git仓库 git init 添加本地仓库建立连接的远程仓库 git remote add 远程仓库起别名 关联的远程仓库 添加你本地仓库修改了文件 git add (文件名/.) 提交修改 git commit -m “提交说明” 将修改内容上传到远程仓库 git push 远程仓库别名 所上传到远程仓库的分支名 （git push origin master） 从远程仓库下载最新内容到本地仓库 git pull 远程仓库别名 下载内容所在的远程仓库分支名 删除本地仓库与远程仓库的关联 git remote rm 远程仓库别名 fork仓库 在github上fork别人仓库到自己github上，clone 自己的该仓库到本地 git clone 自己fork下来的的仓库地址 修改本地仓库文件，并将文件添加到暂存区 git add . 提交修改 git commit -m “提交说明” 将你本地仓库修改文件上传到github git push origin master 到自己的github的该仓库页面进行pull request 处理他人提交的pull request 对别人仓库 issues如果使用他人想买出现bug或又问题 可以发起issues 处理自己仓库的issues: Wiki:为自己仓库创建wiki: 分支： 发布： 标记和发布是共存的。 为当前提交添加标记 git tag “v1” 添加修改当前暂存区 git add . 提交修改 git commit -m “添加标记” 推送提交到远程仓库，包含标记 git push –tags origin master Gist管理gist是用来即时分享代码，注释，和片段代码的。 重要文件说明github仓库中三个重要文件 README.md: 显示在仓库下面的说明文档，markdown语法 LICENSE：代表本场客所遵循的开源协议 .gitignore: 代表git忽略文件 markdown语法 https://guides.github.com/features/mastering-markdown/ .gitignore文件中每一行表示忽略一个文件，支持通配符”*” 忽略目录 : /dir 忽略一类文件： *.bat 不忽略某个文件(和上面匹配)： ！test.bat Githug小游戏(windows)环境配置安装 git: git 安装ruby: ruby 查看是否配置环境变量： ruby –version 换源： gem sources -l gem sources –add https://gems.ruby-china.com –remove https://rubygems.org/ 更新缓存 gem sources -u 安装github小游戏: gem install githug 注意： 如果出现rake冲突，删除不用的rake (gem uninstall rake) githuggithug是设计学习git的小游戏，一共55关，每一关都需要用git命令获取正确答案 常用命令： githug: 开始闯关或者下一关 githug hint: 过关提示 githug levels: 显示关卡列表 githug reset [关卡名]： 重启甭管或者重启到指定关卡名的关卡 githug play：验证操作，成功会进入下一个关卡 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#1: init 初始化 &gt; githug (输入开始闯关)，输入y在当前目录创建一个git_hug的子目录 &gt; git init(进入目录 输入命令) &gt; git play #2: config 配置用户名和邮箱 &gt; git config --local user.name xxx &gt; git config --local user.email xxx@xx &gt; git play #3: add 添加文件 &gt; git add README （添加readme） &gt; githug play #4: commit 提交添加文件 &gt; git commit -m &quot;add readme&quot; &gt; githug play #5: clone 克隆下载仓库 &gt; git clone https://github.com/Gazler/cloneme &gt; githug play #6: clone_to_folder 克隆并指定文件夹名 &gt; git clone https://github.com/Gazler/cloneme my_cloned_repo &gt; githug play #7: ignore 忽略所有swp后缀的文件 &gt; vim .gitignore $ *.swp &gt; githug play #8: include 除了 lib.a文件，其他所有.a都被忽略 &gt; vim .gitignore $ #ignore all file with &apos;.a&apos; extensions except &apos;lib.a&apos; file 注释 $ *.a $ !lib.a &gt; githug play #9: status 查看untracked状态文件 &gt; git status &gt; git play （database.yml） untracked: 仓库新建的文件，被用红字显示在查询结果的 &quot;Untrakced files&quot; 段落中 modified：被编辑过的文件的状态就变为 &quot;modified&quot;，它们被用红字显示在查询结果的 &quot;Changes not staged for commit&quot; 段落中 staged:通过 git add 命令加入到暂存区的文件的状态就变为 &quot;staged&quot;，它们被用绿字显示在查询结果的 &quot;Changes to be committed&quot; 段落中 #10: number_of_files_committed 查看staged状态文件个数，黄色就是 &gt; git status &gt; git play (2) #11: rm 有个文件从硬盘删除，当时并未从git仓库中删除，找到并从git仓库删除(删除也是修改，可以直接提交这个修改) &gt; git status &gt; git add deleteme.rb &gt; git commit -m &quot;remove deleteme.rb&quot; &gt; githug play #12: rm_cached 一个文件以外地加入到你的暂存区，找出这个文件并将它从暂存区移除(--cached)。不要将它从文件系统中移除(--f)，仅仅将它git中移除。 &gt; git status &gt; git rm --cached deleteme.rb &gt; githug play #13: stash 做了一些修改，并且向稍后再它们上面工作。你应该保存它们，但是不提交它们,git中维护一个栈保存,如果需要恢复某次提交，使用 git stash apply（git stash 把当前环境&quot;保护不提交&quot;，git stash list:列出被保护不提交对象, git stash pop：恢复被保护不提交的环境） &gt; git status &gt; git stash &gt; git status &gt; githug play #14: rename 重命名文件。首先这个文件需要是已经是已追踪状态，才可以使用 git mv 命令，操作完成后自动处于 staging 状态 &gt; ls &gt; git mv oldfile.txt newfile.txt &gt; git status &gt; githug play #15: restructure 移动所有 .html 文件到 src 文件夹。git mv 后面的第二个参数可以接受文件或目录，如果是目录，则文件会直接放入目录内，可以使用正则（glob模式）匹配所有 .html 文件 &gt; mkdir src &gt; git mv *.html src &gt; git status &gt; githug play #16: log 找到最新的 commit 的 hash 值。使用 git log 查看历史提交记录, 找到最新的 commit 的 hash 值(git log --pretty=oneline: 把例子以紧凑格式显示) &gt; git log &gt; githug play (输入hash) #17: tag 为最新的 commit 打 tag。不加额外参数就是为当前 commit 记录 tag (git tag name hash：给指定提交打标签,git tag -d name:删除标签，git tag:显示所有标签) &gt; git tag new_tag &gt; githug play #18: push_tags 将所有本地 tag 都推送到远端。--tags 参数代表将所有的 tags 都推送到远端(默认tag是不会上传到远端的) &gt; git push --tags origin master &gt; githug play #19: commit_amend 某个文件在上次提交中遗漏了，在那次提交中补上这个文件。 其实，使用 git commit --amend 会进入编辑界面修改备注信息，我这里直接 :wq 保存并退出(git commit --amend:出现编辑器，编写提交说明，git commit -amend -m &quot;new message&quot;：更新提交说明，git commit --amend -C HEAD:直接使用原有的提交说明，其中 -C 表示使用已提交过的说明，HEAD 表示最近一次提交) &gt; git status &gt; git add forgotten_file.rb &gt; git commit --amend &gt; githug play #20: commit_in_future 为提交指定一个未来的时间 &gt; git status &gt; git commit --date=06.13.2019T21:00:00 -m &quot;指定提交时间为明天&quot; &gt;githug play #21: reset 两个文件都被添加到了 staging area, 但是只想提交其中一个。使用 git reset 可以用仓库中的版本覆盖 staging area 的版本。git reset 使用仓库中的版本覆盖 staging area 中的，如果 working directory 该文件没有其他修改，则 staging area 中的修改将应用到 working directory 中。反之working directory 中的版本将被保留，丢弃 staging area 中的修改。git checkout 则是使用 staging area 的中的版本覆盖 working directory。 &gt; git status &gt; git reset HEAD to_commit_second.rb &gt; git status &gt; git commit -m &quot;add to_commit_first.rb&quot; &gt; githug play #22: reset_soft 撤销上一次提交。--soft 参数将上一次的修改放入 staging area--mixed 参数将上一次的修改放入 working directory--hard 参数直接将上一次的修改抛弃 &gt; git status &gt; git reset --soft HEAD~1 &gt; git status &gt; githug play #23: checkout_file 抛弃某一次的修改，使用上次提交的版本。checkout 和 reset 的区别参照第二十一关 &gt; git status &gt; git checkout config.rb &gt; githug play #24: remote 查看远端仓库，加这个参数只是可以将地址也一起输出 &gt; git remote &gt; githug play (my_remote_repo) #25: remote_url 查看远端仓库的 URL 加上参数 -v &gt; git remote -v &gt; githug play（https://github.com/githug/not_a_repo） #26: pull 拉取远端仓库(git pull 远端别名 分支名)指定分支：git pull origin remote : local对应推送：git push origin local : remote &gt; git remote -v &gt; git pull origin master &gt; githug play #27: remote_add 添加一个远端仓库 &gt; git remote add origin https://github.com/githug/githug &gt; githug play #28: push 推送本地修改到远端 &gt; git status &gt; git rebase origin/master &gt; git push origin master &gt; githug play #29: diff 查看 staging area 和 working directory 中文件的差异。git diff: 查看 working directory 与 staging area 之间的差异git diff --cached: 查看 repository 与 staging area 之间的差异git diff HEAD: 查看 working directory 与 repository 之间的差异 &gt; git diff &gt;githug play（26）#30: blame 有人将密码放进了“config.rb”文件中，找出是谁。 &gt; git blame config.rb &gt; githug play (Spider Man) #31: branch 创建一个分支 &gt; git branch test_code &gt; git branch &gt; githug play #32: checkout 创建一个分支，并切换过去。其实，git checkout -b my_branch 就是创建一个分支，并切换过去(git checkout name：切换分支，git checkout -: 切换到上次分支) &gt; git checkout -b my_branch &gt; git branch &gt;githug play #33: checkout_tag 切换到某个特定的 tag &gt; git tag &gt; git checkout v1.2 &gt; githug play#34: checkout_tag_over_branch 切换到某个特定的分支，但是分支名和标签名重叠了 &gt; git checkout tags/v1.2 &gt; githug play#35: branch_at 根据一个特定的提交创建新分支(git branch name hash) &gt; git branch test_branch HEAD~1 &gt; githug play#36: delete_branch 删除一个分支 &gt; git branch -d delete_me &gt; githug play#37: push_branch 将分支推送到远端仓库 &gt; git branch &gt; git push origin test_branch:test_branch &gt; githug play#38: merge 合并分支。为了简化分支模型，可以使用 rebase 代替，后续关卡会遇到,执行这条命令之前，要先切换到主线（一般是 master 分支），然后把待合并的分支名作为参数。 &gt; git branch &gt; git merge feature &gt; githug play#39: fetch 获取远端的修改，但是并不合并到当前分支。其实，git pull 就是 git fetch 和 git merge 组成的 &gt; git fetch origin &gt; githug play#40: rebase 我们用“git rebase”工作流与“feature”分支准备进入“master”分支。将“feature”分支上的改变合并到“master”上。 git rebase 一个分支的所有修改在另一个分支上重新应用一遍，所以在提交记录上看，会发现一个分支的所有提交在另一个分支之前或者之后。然后删除另一个被合并的分支，保持分支简洁。git rebase master feature 表示将 feature 上的修改在 master 上重新应用一遍 &gt; git log --graph --all &gt; git rebase master feature &gt; git log --graph --all &gt; git checkout feature &gt; git merge master &gt; githug play对应第一个 git log --graph -all ，--graph会用图形化将提交记录显示出来，而--all 会显示所有分支的提交记录对应第而二个 git log --graph -all ，可以发现只保留了一个分支，看起来简洁了很多。在使用此命令的时候，需要非常注意的是，不要 rebase 哪些已经推送到公共库的更新#41 rebase_onto 通过查找，在git rebase中有以下用法： &gt; git rebase --onto master wrong_branch readme-update &gt; githug play#42: repack 将版本库未打包的松散对象打包,它们被存储在 .git/objects/ 目录下： &gt; git repack &gt; git repack -d &gt; githug play #43: cherry-pick 应用某一个提交的修改,如果你创建了一个分支，在其中进行了多次提交，而在合并时不想把分支上所有的提交都合并到主线，只想选取其中的1个提交合并到主线 &gt; git branch &gt; git log --all &gt; git cherry-pick ca32a6d &gt; githug play#44: grep git grep支持各种条件搜索及正则表达式，平时用的不多，但感觉功能强大 &gt; git grep TODO &gt; githug play(4) #45: rename_commit 重命名提交。当涉及提交修改时，应该想到 git rebase -i 命令，它接受可以一个参数（提交的哈希值），它将罗列出此提交之后的所有提交，然后可以对个个提交做对应的操作。 &gt; git log (发现有个提交&quot;First coommit&quot;单词拼写错误) &gt; git rebase -i “hash-code”（找到拼写错误的上一次提交的hash） 修改第一行 reword xxx First coommit 保存关闭 **pick：执行此次提交 reword修改备注内容在提交** 修改 coommit 为 commit 关闭 &gt; githug play #46: squash 合并多个提交。如果要把多次合并合并成一次提交，可以用 git rebase -i 的 squash 命令 &gt; git log --pretty=oneline（查看提交日志） &gt; git rebase -i hash(第一次的hash,因为第二条添加readme后提交了三次) 打开文本吧 Adding readme 后面的三个pick改成&quot;squash&quot; 保存退出会弹出更新说明 &gt; git log --pretty=oneline(发现adding readme上面的上次提交合并了这个提交上) &gt;githug play#47: merge_squash 把名为 long-feature-branch 的分支合并到主干，把分支中的多次提交合并为主干上的一次提交 如果分支曾经提交过多次，那么用上面的语句合并之后，主干的日志也会出现多次提交记录。为了符合本关题意，把分支的多次提交合并为主干上的一次提交，要加一个 squash 参数(记得手动提交，添加参数不会自动提交) &gt; git merge long-feature-branch --squash &gt; git commit -m &quot;merge_squash&quot; &gt; githug play#48: reorder 你提交过几次，但是提交的顺序错了，请调整提交顺序 &gt; git log --pretty=oneline(查看提交日志发现第二次和第三次反了) &gt; git rebase -i hash(initial) 打开编辑器把第二行和第三方内容调整下，保存 &gt; githug play #49: bisect 在开发过程中引入了一个 bug。已知运行 &quot;ruby prog.rb 5&quot; 应该输入 15，你也可以运行 &quot;make test&quot; 进行测试。你需要确定引入 bug 的那次提交的哈希值的前7位这时就可以借助 Git 提供的 bisect 工具来查找是哪次提交引入了 bug。bisect 是用二分法来查找的，就像用二分查找法查找数组元素那样。运行 make test 可以测试程序是否正确执行，它会先执行 &quot;ruby prog.rb 5&quot; 语句，然后再分析输出结果是否等于15，如果不等于15，就会显示 make: *** [test] Error 1 &gt; git log --pretty=oneline(查看提交历史，一共20次提交) # 启动bisect查找流程 &gt; git bisect start &gt; git bisect good f608824 &gt; git bisect bad 12628f4 第2行和第3行是定义 bisect 的查找范围，git bisect good 和 git bisect bad 表示当前程序通过或没有通过测试，在第2行后面以第一次提交的哈希值为参数，在第3行后面以最后一次提交的哈希值为参数，说明查找范围是全部20次提交。接着 Git 定位了位于中间那个提交，它的哈希值是 &quot;fdbfc0d403e5a&quot;，并计算出剩余的提交还有9次，大约还需要3次二分查找 这时，我们对程序进行测试，测试通过，所以我们反馈 good &gt; make test &gt; git bisect good Git 继续进行二分查找，这次定位的哈希值是 &quot;18ed2ac1522a01&quot;，我们再对程序测试，测试没有通过，所以我们反馈 bad &gt; make test &gt; git bisect bad //继续 &gt; make test &gt; git bisect good &gt; make test &gt; git bisect good &gt; githug play(18ed2ac) #50: stage_lines 你修改了一个文件的多处代码，这些代码分属于2个不同的功能，代码还没有提交到暂存区。仅提交第1个功能相关的代码到暂存区用 git add 命令可以把文件添加到暂存区，但如果你不想把文件中的全部修改都提交到暂存区，或者说你只想把文件中的部分修改提交到缓存区，那么你需要加上 edit 参数 &gt; git status -s（查看文件状态） &gt; git diff feature.rb（从最后2行可以看出，新增的代码分别对应2个不同的功能，如果我们只想提交第1个功能的代码，删除掉最后一行即可） &gt; git add feature.rb --edit 删除最后一行保存 &gt; git status -s &gt; git diff feature.rb &gt; githug play #51: find_old_branch 你在一个分支上工作时，被分派处理一个重要的问题，可是处理完这个问题之后，你忘了刚才是在哪个分支上工作了。切换回那个分支。 git reflog命令不仅与文件相关的 git commit 操作被记录了，连你 git checkout 操作也都记下来了，现在，你就知道此前是怎么在各个分支之间跳转的了。 &gt; git branch &gt; git reflog &gt; git checkout solve_world_hunger &gt; githug play #52: revert 你提交了多次，但想取消中间的某次提交。所有提交的内容都已经推送到服务端了，所以你不能改变已有的历史 我们曾用过修改提交历史的 git rebase -i 命令，用此方法可以取消多次提交中的某次提交，不过，这只是针对还没有推送到服务端的情况，如果已经提交到服务端，你就不能改变已有的历史了，只能想别的办法解决了。Git 提供了 revert 工具来解决这种问题，它相当于是对某次提交的逆操作，比如你提交时新建了一个文件，那么 Git 就会创建一个删除此文件的提交 git revert hash; git revert hash --no-edit;其中的 hash 就是你要取消的提交的哈希值。第2条命令中的 no-edit 参数表示由系统自动生成一句提交说明，如果没有这个参数，Git 会自动调用文本编辑器请你编写提交说明 &gt; git log --pretty=oneline &gt; git revert hash --no-edit(bad hash) &gt; git log --pretty=oneline &gt; githug play #53: restore 你决定用 git reset --hard HEAD^ 删除最后一次提交（一个不太明智的决定），然后你又反悔了，想回退到这条命令之前。请恢复被删除的提交 &gt; git log --pretty=oneline(查看提交历史两条) &gt; git reflog 有过第3次提交，不过被 git reset --hard HEAD^ 删除掉了。git reset --hard HEAD^ 用于删除最后一次提交，使工作区恢复到上一次提交时的状态，仔细观察上面的操作日志也能发现，其中 &quot;HEAD@&#123;2&#125;&quot; 和 &quot;HEAD@&#123;0&#125;&quot; 的哈希值是一样的（git reset --hard hash:撤销删除命令） &gt; git reset --hard 38c8689(HEAD@&#123;1&#125;) &gt; git reflog &gt; githug play #54: conflict 你要把名为 mybranch 的分支合并到当前分支 master 中，但是可能有些地方的修改会引起冲突。请解决冲突，完成合并 &gt; git branch &gt; git merge mybranch(合并存在冲突) &gt; vim poem.txt 7个左尖括号 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 和7个右尖括号 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 之间的区域是冲突的部分，而中间的7个等号 ======= 则把有冲突的代码分开，上部分是你的代码（通常是主线代码），下部分是别人的代码（通常是开发分支的代码）。编辑这部分内容，保留你想要的，删除你不要的(特殊符号也需要删除)，保存退出，再单独提交这个文件即可 &gt; git status -s &gt; git add poem.txt &gt; git commit -m &quot;解决冲突&quot; &gt; githug play #55: submodule 如果你想把别人的仓库代码作为自己项目一个库来使用，可以采用模块化的思路，把这个库作为模块进行管理。Git 专门提供了相应的工具（git submodule add url） &gt; git submodule add https://github.com/jackmaney/githug-include-me &gt; githug play #56: contribute 这是最后一关，目标是让你在 Github 上提交一个 pull request 贡献。设计本关的目的就是鼓励你向 Githug 提交贡献，而不是测试你使用 pull request 的技能。贡献包括新的关卡、修复BUG和改善文档]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础知识07]]></title>
    <url>%2F2019%2F05%2F29%2FC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8607%2F</url>
    <content type="text"><![CDATA[第七章：函数探幽 内联函数内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。 使用： 在函数声明前加上关键字inline； 在函数定义前加上关键字inline。 程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己（内联函数不能递归），因此不将其作为内联函数；而有些编译器没有启用或实现这种特性。 引用变量C++新增了一种复合类型——引用变量。引用是已定义的变量的别名（另一个名称），引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。 创建引用变量C和C++使用&amp;符号来指示变量的地址。C++给&amp;符号赋予了另一个含义，将其用来声明引用。 “int a=10; int &amp; rodents =a;” &amp;不是地址运算符，而是将rodents的类型声明为int &amp;，即指向int变量的引用,引用声明允许将a和rodents互换，它们指向相同的值和内存单元 int pt =&a; 这是指向a的指针，rodents 和pt都可以和a互换，表达式&amp;rodents和pt都可以和&amp;a互换。引用和指针在表示方法不同，必须在声明引用时将其初始化，不能像执政一样，先声明在初始化(int a; int &yy; yy=a; //错误)。 引用接近const指针，必须在创建时初始化，并且不能改变 int &amp; rodents =a; //引用 int * const pr = &a; //伪指针表示 将引用作为函数参数引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//交换两个变量的值#include &lt;iostream&gt;void swapA(int &amp;a, int &amp;b); //引用void swapB(int *p, int *q); //指针void swapC(int a, int b); //值int main()&#123; using namespace std; int num1 = 300; int num2 = 100; cout &lt;&lt; "num1 = $" &lt;&lt; num1; cout &lt;&lt; "num2 = $" &lt;&lt; num2 &lt;&lt; endl; //使用引用交换 swapA(num1, num2); cout &lt;&lt; "num1 = $" &lt;&lt; num1; cout &lt;&lt; "num2 = $" &lt;&lt; num2 &lt;&lt; endl; //使用指针进行交换 swapB(&amp;num1, &amp;num2); cout &lt;&lt; "num1 = $" &lt;&lt; num1; cout &lt;&lt; "num2 = $" &lt;&lt; num2 &lt;&lt; endl; // 使用值 进行交换(不可以修改原始数据，所以失败) swapC(num1, num2); cout &lt;&lt; "num1 = $" &lt;&lt; num1; cout &lt;&lt; "num2 = $" &lt;&lt; num2 &lt;&lt; endl; return 0;&#125;void swapA(int &amp;a, int &amp;b)&#123; int tmp; tmp = a; a = b; b = tmp;&#125;void swapB(int *a, int *b)&#123; int tmp; tmp = *a; *a = *b; *b = tmp;&#125;void swapC(int a, int b)&#123; int tmp; tmp = a; a = b; b = tmp;&#125;---------------------------------------------/* 按引用传递和按值传递看起来相同,然而，地址运算符（&amp;）使得按地址传递.swapA( )中，变量a和b是别名，所以交换a和b的值相当于交换num1,2的值；swapC( )中，变量a和b是复制了num1和num2的值的新变量，因此交换a和b的值并不会影响原值。swapB()指针版本需要在函数使用p和q的整个过程中使用解除引用运算符*,*/ 引用属性和特别之处使用引用前面添加关键字const(double xx(const double &amp;ra);) ,当编译器发现修改了ra的值，将生成错误消息。 临时变量、引用参数和const 如果实参与引用参数不匹配，C++将生成临时变量， 如果引用参数是const，则编译器子啊两种情况下生成临时变量(实参的类型正确，但不是左值;实参的类型不正确，但可以转换为正确的类型)左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量（用引号括起的字符串除外，它们由其地址表示）和包含多项的表达式 C++11新增了另一种引用——右值引用。这种引用可指向右值，是使用&amp;&amp;声明的,新增右值引用的主要目的是，让库设计人员能够提供有些操作的更有效实现. 引用与结构引入引用主要是为了用于这些类型的，而不是基本的内置类型。 使用结构引用参数的方式与使用基本变量引用相同，只需在声明结构参数时使用引用运算符&amp;即可。如果不希望函数修改传入的结构，可使用const。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//结构体struct free_throws&#123; string name; int made; int attempts; float percent;&#125;;//函数原型void show(const free_throws &amp;ft);void set_pc(free_throws &amp;ft);free_throws &amp;accumulate(free_throws &amp;target, const free_throws &amp;source);int main()&#123; //初始化了多个结构对象，结构percent未进行初始化 被设置为0 free_throws one = &#123;"Hello World", 13, 14&#125;; free_throws two = &#123;"good mon", 10, 16&#125;; free_throws three = &#123;"Li ming", 7, 9&#125;; free_throws four = &#123;"Han xx", 5, 9&#125;; free_throws five = &#123;"long long", 6, 14&#125;; free_throws team = &#123;"endend", 0, 0&#125;; free_throws dup; /* et_pc()的形参ft为引用,因此ft指向one， 函数set_pc()的代码设置成员one.percent 也可用指针传递 set_pc(&amp;one) void set_pc(free_throws *pt) */ set_pc(one); /* display()显示结构的内容，而不修改它，因此这个函数使用了一个const引用参数 这个函数可以按值传递，也可以这样引用传递，但引用传递节省时间和内存。 */ show(one); /* accumulate()接收两个结构参数, 并将第二个结构的成员attempts和made的数据添加到第一个结构的相应成员中 只修改了第一个结构，因此第一个参数为引用，而第二个参数为const引用 */ accumulate(team, one); show(team); /* 将结构对象team作为第一个参数传递给了accumulate(),target指向的是team 数accumulate()修改team，再返回指向它的引用 如果返回类型被声明为free_throws而不是free_throws &amp;， 上述返回语句将返回target（也就是team）的拷贝。 但返回类型为引用，这意味着返回的是最初传递给accumulate()的team对象 接下来，将accumulate()的返回值作为参数传递给了show()，这意味着将team传递给了show()。 show()的参数为引用，这意味着函数show()中的ft指向的是team，因此将显示team的内容 //等同下面： accumulate(team, two); show(team); */ show(accumulate(team, two)); /* 同上 show(accumulate(team, two)); 可以写成： accumulate(team, three); accumulate(team, four); */ accumulate(accumulate(team, three), four); show(team); //赋值语句，将team赋值到dup dup = accumulate(team, five); cout &lt;&lt; "show team:\n"; show(team); cout &lt;&lt; "show dup after assignment:\n"; show(dup); set_pc(four); /* 这条语句将值赋给函数调用，这是可行的，因为函数的返回值是一个引用。 如果函数accumulate()按值返回，这条语句将不能通过编译。 由于返回的是指向dup的引用，因此上述代码与下面的代码等效 accumulate(dup, five); dup=four; 其中第二条语句消除了第一条语句所做的工作， 因此在原始赋值语句使用accumulate()的方式并不好 */ accumulate(dup, five) = four; cout &lt;&lt; "show dup after ill-advised assignment:\n"; show(dup); return 0;&#125;void show(const free_throws &amp;ft)&#123; cout &lt;&lt; "Name: " &lt;&lt; ft.name &lt;&lt; '\n'; cout &lt;&lt; "Made: " &lt;&lt; ft.made &lt;&lt; '\t'; cout &lt;&lt; "Attempts: " &lt;&lt; ft.attempts &lt;&lt; '\t'; cout &lt;&lt; "Percent: " &lt;&lt; ft.percent &lt;&lt; '\n';&#125;void set_pc(free_throws &amp;ft)&#123; if (ft.attempts != 0) ft.percent = 100.0f * float(ft.made) / float(ft.attempts); else ft.percent = 0;&#125;free_throws &amp;accumulate(free_throws &amp;target, const free_throws &amp;source)&#123; target.attempts += source.attempts; target.made += source.made; set_pc(target); return target;&#125;/*Name: Hello WorldMade: 13 Attempts: 14 Percent: 92.8571Name: endendMade: 13 Attempts: 14 Percent: 92.8571Name: endendMade: 23 Attempts: 30 Percent: 76.6667Name: endendMade: 35 Attempts: 48 Percent: 72.9167show team:Name: endendMade: 41 Attempts: 62 Percent: 66.129show dup after assignment:Name: endendMade: 41 Attempts: 62 Percent: 66.129show dup after ill-advised assignment:Name: Han xxMade: 5 Attempts: 9 Percent: 55.5556*/ 探究程序 返回引用与传统返回机制的不同之处: 传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而调用程序将使用这个值。如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为引用时，将直接把team复制到dup，其效率更高。 返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用也将指向这些数据。另一种方法是用new来分配新的存储空间。前面见过这样的函数，它使用new为字符串分配内存空间，并返回指向该内存空间的指针。注意：在不再需要new分配的内存时，应使用delete来释放它们。调用clone( )隐藏了对new的调用，这使得以后很容易忘记使用delete来释放内存。 将const用于引用返回类型：假设您要使用引用返回值，但又不允许执行像给accumulate()赋值这样的操作，只需将返回类型声明为const引用，现在返回类型为const，是不可修改的左值。 将引用用于类对象将类对象传递给函数时，C++通常的做法是使用引用(函数将类string、ostream、istream、ofstream和ifstream等类的对象作为参数)。 对象继承和引用ofstream对象可以使用ostream类的方法，这使得文件输入/输出的格式与控制台输入/输出相同。使得能够将特性从一个类传递给另一个类的语言特性被称为继承。简单地说，ostream是基类（因为ofstream是建立在它的基础之上的），而ofstream是派生类（因为它是从ostream派生而来的）。派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性，如格式化方法precision( )和setf( )。继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数。例如，参数类型为ostream &amp;的函数可以接受ostream对象（如cout）或您声明的ofstream对象作为参数。 使用应用参数 程序员能够修改调用函数中的数据对象。 通过传递引用而不是整个数据对象，可以提高程序的运行速度 当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。 对于使用传递的值而不作修改的函数： 果数据对象很小，如内置数据类型或小型结构，则按值传递。 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。 对于修改调用函数中数据的函数： 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit（&amp;x）这样的代码（其中x是int），则很明显，该函数将修改x。 如果数据对象是数组，则只能使用指针。 如果数据对象是结构，则使用引用或指针 如果数据对象是类对象，则使用引用 默认参数默认参数指的是当函数调用中省略了实参时自动使用的一个值(缺省值)，这极大地提高了使用函数的灵活性。 设置默认值必须通过函数原型。 char left(const char str, int n = 1); //n=1 对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值 int fun1 (int n =1, int m, int j =5) //错误 int fun2( int n, int m=1, int j=5) //可以 函数重载函数多态是C++在C语言的基础上新增的功能。默认参数让您能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数。术语“多态”指的是有多种形式，因此函数多态允许函数可以有多种形式。类似地，术语“函数重载”指的是可以有多个同名的函数，因此对名称进行了重载。 函数重载的关键是函数的参数列表——也称为函数特征标。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同，例如print函数。 注意： int fun(int x) 和 int fun(int &amp; x)，不是重载， 译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。重载也不区分const。是特征标，而不是函数类型使得可以对函数进行重载。 虽然函数重载很吸引人，但也不要滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。 使用一个带默认参数的函数要简单些。只需编写一个函数（而不是两个函数），程序也只需为一个函数（而不是两个）请求内存；需要修改函数时，只需修改一个。然而，如果需要使用不同类型的参数，则默认参数便不管用了，在这种情况下，应该使用函数重载。 函数模版C++编译器实现了C++新增的一项特性——函数模板。函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型（如int或double）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型。 template // 准C++98添加关键字typename之前，C++使用关键字class template 重载模版 并非所有的类型都使用相同的算法。为满足这种需求，可以像重载常规函数定义那样重载模板定义。和常规重载一样，被重载的模板的函数特征标必须不同. template void Swap(T &amp;a, T &amp;b); template void Swap(T ，T b, int n); 实例化和具体化 最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许显式实例化。可以直接命令编译器创建特定的实例,如Swap( )。其语法是，声明所需的种类——用&lt;&gt;符号指示类型，并在声明前加上关键字template template void Swap(int, int ) 显式具体化使用下面两个等价的声明之一 template &lt;&gt; void Swap (int &amp;, int &amp;); template &lt;&gt; void Swap(int &amp;， int &amp;); 区别在于，这些声明的意思是“不要使用Swap( )模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义”。这些原型必须有自己的函数定义。显式具体化声明在关键字template后包含&lt;&gt;，而显式实例化没有。 问答 那种函数适合定义内联函数 一行代码的小型 非递归函数 函数原”void song(const char * name, int times);”,提供默认值修改 void song(char * name = “Hello”, int times=1) 编写iquote( )的重载版本——显示其用双引号括起的参数。编写3个版本：一个用于int参数，一个用于double参数，另一个用于string参数。 123456789void iquote(int n)&#123; cout&lt;&lt;"\""&lt;&lt;n&lt;&lt;"\"";&#125;void iquote(double x)&#123; cout&lt;&lt;'"'&lt;&lt;x&lt;&lt;'"';&#125;void iquote(const char *str)&#123; cout&lt;&lt;"\""&lt;&lt;str&lt;&lt;"\"";&#125; 给出一个结构体，编写函数，将box结构因为形参，并显示结构成员值，并且求体积 12345678910111213141516struct box&#123; char maker[20]; float height; float width; float length; float volume;&#125;//显示成员void show (const box &amp; container)&#123; cout&lt;&lt;container.make&lt;&lt;endl; ...&#125;//计算体积void Calvolume(box &amp; crate)&#123; create.volume = create.height * create.width * create.length;&#125; 指出下面每个目标是否可以使用默认参数或函数重载完成，或者这两种方法都无法完成，并提供合适的原型。 12345678910111213141516/* mass(density, volume)返回密度为density、体积为volume的物体的质量，而mass(denstity)返回密度为density、体积为1.0立方米的物体的质量。这些值的类型都为double。 */double mass(double d, double v=1.0);//重载double mass(double d, double v);double mass(double d);/* repeat(10, “I'm OK”)将指定的字符串显示10次，而repeat(“But you're kind of stupid”)将指定的字符串显示5次。 */void repeat(int times, const char * str);void repeat(const char *str);/* average(3, 6)返回两个int参数的平均值（int类型），而average(3.0, 6.0)返回两个double值的平均值（double类型） */int average(int a, int b);double average(double x, double y);/* mangle(“I'm glad to meet you”)根据是将值赋给char变量还是char*变量，分别返回字符I和指向字符串“I'm mad to gleet you”的指针 */不可以这么做，因为两个版本特征标相同。 编写返回两个参数中较大值的函数模板 1234template&lt;class T&gt;T max(T t1, T t2)&#123; return t1&gt;t2 ? t1:t2; &#125; 给定问答5的模板和问答4的box结构，提供一个模板具体化，它接受两个box参数，并返回体积较大的一个。 123template&lt;&gt; box max(box b1, box b2)&#123; return b1.volume &gt; b2.volume ? b1:b2;&#125; 看程序指出v1-v5类型 123456789int g（int x）;...float m = 5.5f;float &amp; rm =m;decltype(m) v1 =m; //floatdecltype(rm) v2 =m; //float &amp;decltype((m)) v3 =m; //float &amp;decltype(g(100)) v4; // int decltype(2.0*m) v5; //double 代码 接受一个参数（字符串的地址），并打印该字符串的函数。然而，如果提供了第二个参数（int类型），且该参数不为0，则该函数打印字符串的次数将为该函数被调用的次数(int 为函数调用次数。) 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;unsigned k_times = 0;void print_times(const char *szTmp, int flag = 0)&#123; ++k_times; unsigned uPrintfTimes = (0 == flag) ? 1 : k_times; cout &lt;&lt; "&gt;&gt;&gt;&gt;" &lt;&lt; endl; for (unsigned i = 0; i &lt; uPrintfTimes; ++i) &#123; cout &lt;&lt; szTmp &lt;&lt; endl; &#125; cout &lt;&lt; "&lt;&lt;&lt;&lt;" &lt;&lt; endl; cout &lt;&lt; "-----------------" &lt;&lt; endl;&#125;int main(void)&#123; const char *szTxt = "hi, yangyang.gnu"; print_times(szTxt, 8); print_times(szTxt); print_times(szTxt, -1); print_times(szTxt); print_times(szTxt, 256); cout &lt;&lt; endl; return (0);&#125; CandyBar结构包含3个成员。第一个成员存储candy bar的品牌名称；第二个成员存储candy bar的重量（可能有小数）；第三个成员存储candy bar的热量（整数）。请编写一个程序，它使用一个这样的函数，即将CandyBar的引用、char指针、double和int作为参数，并用最后3个值设置相应的结构成员。最后3个参数的默认值分别为“Millennium Munch”、2.85和350。另外，该程序还包含一个以CandyBar的引用为参数，并显示结构内容的函数。请尽可能使用const. 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;struct TCandyBar&#123; string strBrand; double weight; int calories;&#125;;void set_candybar(TCandyBar &amp;candbar, const char *strBrand = "Millennium Munch", double weight = 2.85, int calories = 350)&#123; candbar.strBrand = strBrand; candbar.weight = weight; candbar.calories = calories;&#125;void show_candybar(const TCandyBar &amp;candbar)&#123; cout &lt;&lt; candbar.strBrand &lt;&lt; '\t' &lt;&lt; candbar.weight &lt;&lt; '\t' &lt;&lt; candbar.calories &lt;&lt; endl;&#125;int main(void)&#123; TCandyBar candbar1, candbar2; set_candybar(candbar1); show_candybar(candbar1); set_candybar(candbar2, "yang yang", 3.11, 256); show_candybar(candbar2); cout &lt;&lt; endl; return (0);&#125; 编写一个函数，它接受一个指向string对象的引用作为参数，并将该string对象的内容转换为大写，可使用函数toupper( )。然后编写一个程序，它通过使用一个循环让您能够用不同的输入来测试这个函数. 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;string &amp;str_to_upper(string &amp;str)&#123; for (auto &amp;e : str) &#123; e = (char)toupper(e); &#125; return (str);&#125;int main(void)&#123; while (true) &#123; cout &lt;&lt; "Enter a string (q to quit): "; string strInput; getline(cin, strInput); if (!cin || "q" == strInput || "Q" == strInput) &#123; break; &#125; cout &lt;&lt; str_to_upper(strInput) &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 请提供已知代码描述的函数和原型，从而完成该程序。注意，应有两个show( )函数，每个都使用默认参数。请尽可能使用cosnt参数。set( )使用new分配足够的空间来存储指定的字符串。这里使用的技术与设计和实现类时使用的相似 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct stringy&#123; char *str; int ct;&#125;;void set(stringy &amp;stry, const char *szTxt)&#123; stry.ct = (int)strlen(szTxt); stry.str = new char[stry.ct + 1]; strcpy(stry.str, szTxt);&#125;void show(const char *szTxt, unsigned times = 1)&#123; for (unsigned i = 0; i &lt; times; ++i) &#123; cout &lt;&lt; szTxt &lt;&lt; endl; &#125;&#125;void show(const stringy &amp;stry, unsigned times = 1)&#123; for (unsigned i = 0; i &lt; times; ++i) &#123; cout &lt;&lt; stry.str &lt;&lt; endl; &#125;&#125;void destroy(stringy &amp;stry)&#123; delete[] stry.str; stry.str = NULL;&#125;int main()&#123; stringy beany; char testing[] = "Reality isn't what it used to be."; set(beany, testing); show(beany); show(beany, 2); destroy(beany); testing[0] = 'D'; testing[1] = 'u'; show(testing); show(testing, 3); show("Done!"); return 0; // prints member string once // prints member string twice // prints testing string once // prints testing string thrice&#125; 编写模板函数max5( )，它将一个包含5个T类型元素的数组作为参数，并返回数组中最大的元素（由于长度固定，因此可以在循环中使用硬编码，而不必通过参数来传递）。在一个程序中使用该函数，将T替换为一个包含5个int值的数组和一个包含5个dowble值的数组，以测试该函数. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;array&gt;using namespace std;template &lt;typename T&gt;const T &amp;max5(const array&lt;T, 5&gt; &amp;arr)&#123; unsigned idxMax = 0; for (unsigned i = 0; i &lt; 5; ++i) &#123; if (arr[i] &gt; arr[idxMax]) &#123; idxMax = i; &#125; &#125; return (arr[idxMax]);&#125;int main(void)&#123; array&lt;int, 5&gt; iArray = &#123;&#123;32, -1, 99, 256, 9&#125;&#125;; for (const auto &amp;e : iArray) &#123; cout &lt;&lt; e &lt;&lt; ' '; &#125; cout &lt;&lt; " ----max: " &lt;&lt; max5(iArray) &lt;&lt; endl; array&lt;double, 5&gt; dArray = &#123;&#123;-3.2, 221.22, 9.9, 0, 1&#125;&#125;; for (const auto &amp;e : dArray) &#123; cout &lt;&lt; e &lt;&lt; ' '; &#125; cout &lt;&lt; " ----max: " &lt;&lt; max5(dArray); cout &lt;&lt; endl; return 0;&#125; 编写模板函数maxn( )，它将由一个T类型元素组成的数组和一个表示数组元素数目的整数作为参数，并返回数组中最大的元素。在程序对它进行测试，该程序使用一个包含6个int元素的数组和一个包含4个double元素的数组来调用该函数。程序还包含一个具体化，它将char指针数组和数组中的指针数量作为参数，并返回最长的字符串的地址。如果有多个这样的字符串，则返回其中第一个字符串的地址。使用由5个字符串指针组成的数组来测试该具体化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;template &lt;typename T&gt;const T &amp;maxn(const T arr[], unsigned n)&#123; unsigned idxMax = 0; for (unsigned i = 0; i &lt; n; ++i) &#123; if (arr[i] &gt; arr[idxMax]) &#123; idxMax = i; &#125; &#125; return (arr[idxMax]);&#125;const char *maxn(const char *arr[], unsigned n)&#123; unsigned idxMax = 0; for (unsigned i = 0; i &lt; n; ++i) &#123; if (strlen(arr[i]) &gt; strlen(arr[idxMax])) &#123; idxMax = i; &#125; &#125; return (arr[idxMax]);&#125;int main(void)&#123; int iArray[] = &#123;32, -1, 99, 0, 256, 9&#125;; for (const auto &amp;e : iArray) &#123; cout &lt;&lt; e &lt;&lt; ' '; &#125; cout &lt;&lt; " ----max: " &lt;&lt; maxn(iArray, sizeof(iArray) / sizeof(iArray[0])) &lt;&lt; endl; double dArray[] = &#123;-3.2, 221.22, 9.9, 0, 1&#125;; for (const auto &amp;e : dArray) &#123; cout &lt;&lt; e &lt;&lt; ' '; &#125; cout &lt;&lt; " ----max: " &lt;&lt; maxn(dArray, sizeof(dArray) / sizeof(dArray[0])) &lt;&lt; endl; const char *szArray[] = &#123; "aa aa", "dddddddddddd", "", "fffffff ffff", "kk kk", &#125;; for (const auto &amp;e : szArray) &#123; cout &lt;&lt; '\"' &lt;&lt; e &lt;&lt; '\"' &lt;&lt; ' '; &#125; cout &lt;&lt; " ----max: " &lt;&lt; '\"' &lt;&lt; maxn(szArray, sizeof(szArray) / sizeof(szArray[0])) &lt;&lt; '\"' &lt;&lt; endl; cout &lt;&lt; endl; return 0;&#125; 使用两个名为 SumArray()的模板函数来返回数组元素的总和，而不是显示数组的内容。程序应显示thing的总和以及所有debt的总和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;struct debts&#123; char name[50]; double amount;&#125;;template &lt;typename T&gt;double SumArray(T arr[], int n)&#123; using namespace std; cout &lt;&lt; "template A\n"; double sum = 0; for (int i = 0; i &lt; n; i++) sum += arr[i]; return (sum);&#125;template &lt;typename T&gt;double SumArray(T *arr[], int n)&#123; using namespace std; cout &lt;&lt; "template B\n"; double sum = 0; for (int i = 0; i &lt; n; i++) sum += *arr[i]; return (sum);&#125;int main()&#123; using namespace std; int things[6] = &#123;13, 31, 103, 301, 310, 130&#125;; struct debts mr_E[3] = &#123;&#123;"Ima Wolfe", 2400.0&#125;, &#123;"Ura Foxe", 1300.0&#125;, &#123;"Iby Stout", 1800.0&#125;&#125;; double *pd[3]; for (int i = 0; i &lt; 3; i++) pd[i] = &amp;mr_E[i].amount; cout &lt;&lt; "the total number of Mr. E's things:\n" &lt;&lt; SumArray(things, 6) &lt;&lt; endl; cout &lt;&lt; "the sum of Mr. E's all debts:\n" &lt;&lt; SumArray(pd, 3); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础知识06]]></title>
    <url>%2F2019%2F05%2F27%2FC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8606%2F</url>
    <content type="text"><![CDATA[第六章：函数 函数的基本知识使用函数必须遵守以下几点 提供函数定义； 提供函数原型； 调用函数。 函数定义可以将函数分成两类：没有返回值的函数和有返回值的函数。 没有返回值的函数被称为void函数 void funName(paraList){ xxxx; return; } 有返回值的函数将生成一个值，并将它返回给调用函数 typeName funName(paralist){ xxxx; return value; } 函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据 函数原型函数原型： 原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器 double value = add(num); 原型告诉编译器，add( )有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，add( )函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数（这里为main( )）将从这个位置取得返回值。由于原型指出了add( )的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。 使用原型：编译器如果在文件中一步步查找，效率是不高的，并且C++允许将一个程序放在多文件中，单独编译这些文件。这种情况下，编译器在编译main时，可能无权访问函数代码。如果函数位于库种，也是如此。 原型语法 函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号,函数原型不需要提供变量名，有类型列表就行。 double add(double num) void result(int) 原型功能 编译器正确处理函数返回值； 编译器检查使用的参数数目是否正确； 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话） 函数参数和按值传递C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其赋给一个新的变量。用于接收传递值的变量被称为形参。传递给函数的值被称为实参。出于简化的目的，C++标准使用参数（argument）来表示实参，使用参量（parameter）来表示形参，因此参数传递将参量赋给参数 在函数中声明的变量（包括参数）是该函数私有的。在函数被调用时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些变量使用的内存，这样的变量被称为局部变量，因为它们被限制在函数中，这样做有助于确保数据的完整性。 多个参数 函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可，同样，在定义函数时，也在函数头中使用由逗号分隔的参数声明列表。 函数和数组函数参数和返回值的类型可以是基本类型，也可以是处理更复杂的类型（如数组和结构） 使用指针处理数组C++和C语言一样，也将数组名视为指针，C++将数组名解释为其第一个元素的地址(arrName=&amp;arrName[0]),该规则有一些例外,首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个数组的长度,第三将地址运算符&amp;用于数组名时，将返回整个数组的地址，例如&amp;cookies(cookies长度为8)将返回一个32字节内存块的地址（如果int长4字节）。 int sum = sum_arr(cookies, length) //调用 int sum_arr(int * arr, int n) //原型 cookies是数组名，而根据C++规则，cookies是其第一个元素的地址，因此函数传递的是地址。由于数组的元素的类型为int，因此cookies的类型必须是int指针，即int 。其中用int arr替换了int arr [ ]。这证明这两个函数头都是正确的，因为在C++中，当（且仅当）用于函数头或函数原型中，int arr和int arr [ ]的含义才是相同的。它们都意味着arr是一个int指针。然而，数组表示法（int arr[ ]）提醒用户，arr不仅指向int，还指向int数组的第一个int。当指针指向数组的第一个元素时，可以使用数组表示法，而当指针指向一个独立的值时，使用指针表示法。在其他的上下文中，int arr和int arr [ ]的含义并不相同。例如，不能在函数体中使用int tip[ ]来声明指针。 鉴于变量arr实际上就是一个指针，函数的其余部分是合理的，将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型的长度（以字节为单位）相等的值。对于遍历数组而言，使用指针加法和数组下标时等效的。记住下面两个恒等式 arr[i] == *(ar+i) &amp;arr[i]==ar+i 将数组作为参数代表什么函数调用sum_arr(coolies, ArSize)将cookies数组第一个元素的地址和数组中的元素数目传递给sum_arr( )函数。sum_arr( )函数将cookies的地址赋给指针变量arr，将ArSize赋给int变量n。意味着：实际上并没有将数组内容传递给函数，而是将数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数有了这些信息后，函数便可以使用原来的数组。传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。实际上，这种区别并不违反C++按值传递的方法，sum_arr( )函数仍传递了一个值，这个值被赋给一个新变量，但这个值是一个地址，而不是数组的内容。 数组名与指针对应是好事吗？确实是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。在经典的C语言中，这确实是一个问题，但ANSI C和C++中的const限定符提供了解决这种问题的办法。 更多数组函数示例选择使用数组来表示数据时，实际上是在进行一次设计方面的决策。但设计决策不仅仅是确定数据的存储方式，还涉及到如何使用数据。编写特定的函数来处理特定的数据操作是有好处的（这里讲的好处指的是程序的可靠性更高、修改和调试更为方便）。另外，构思程序时将存储属性与操作结合起来，便是朝OOP思想迈进了重要的一步；以后将证明这是很有好处的。 填充数组 由于接受数组名参数的函数访问的是原始数组，而不是其副本，因此可以通过调用该函数将值赋给数组元素。该函数的一个参数是要填充的数组的名称 int fill_arr(double ar[], int limit) //原型 该函数接受两个参数，一个是数组名，另一个指定了要读取的最大元素数；该函数返回实际读取的元素数，如果是5个元素，例如，如果使用该函数来处理一个包含5个元素的，则将5作为第二个参数。 可以使用循环连续地将值读入到数组中，但如何提早结束循环呢？一种方法是，使用一个特殊值来指出输入结束。由于所有的属性都不为负，因此可以使用负数来指出输入结束。另外，该函数应对错误输入作出反应，如停止输入等。 1234567891011121314151617181920int fill_arr(double ar[], int limit)&#123; using namespace std; double temp; int i; for (i=0; i&lt; limit; i++)&#123; cout&lt;&lt;"Enter value #"&lt;&lt;(i+1)&lt;&lt;": "; cin &gt;&gt; temp; if (!cin)&#123; //非法输入 cin.clear()； while (cin.get()!='\n') continue; cout&lt;&lt;"bad input. \n" break; &#125; else if (temp &lt;0) break; ar[i] = temp; &#125; return i;&#125; 输入非负值，将赋值给数组，否则循环结束，如果用户输入的都是有效值，则循环将在读取最大数目的值后结束。循环完成的最后一项工作是将i加1，因此循环结束后，i将比最后一个数组索引大1，即等于填充的元素数目。然后，函数返回这个值。 显示数组及用const保护数组 创建显示数组内容的函数，只需将数组名和填充的元素数目传递给函数，然后该函数使用循环来显示每个元素。确保显示函数不修改原始数组。除非函数的目的就是修改传递给它的数据，否则应避免发生这种情况。使用普通参数时，这种保护将自动实现，由于C++按值传递数据，而且函数使用数据的副本，接受数组名的函数将使用原始数据，这正是fill_array( )函数能够完成其工作的原因。为防止函数无意中修改数组的内容，可在声明形参时使用关键字const void show_arr(const double ar[], int n) 该声明表明，指针ar指向的是常量数据。这意味着不能使用ar修改该数据，也就是说，可以使用像ar[0]这样的值，但不能修改。注意，这并不是意味着原始数组必须是常量，而只是意味着不能在show_array( )函数中使用ar来修改这些数据。因此，show_array( )将数组视为只读数据 如果对数组进行改变(ar[0]+=10)，则回出现错误(cannot modify a const) 1234567//显示数组void show (const int num[], int n)&#123; using namespace std； for (int i=0; i&lt;n; i++)&#123; cout &lt;&lt;num[i]&lt;&lt;endl; &#125;&#125; 修改数组 函数将修改数组的值，因此在声明ar时，不能使用const。 数组处理函数常用的编写方式 处理double数组的函数 void f_modify(double arr[],int n); //可修改 void f_nochange(const double arr[],int n); //不修改 使用数组区间的函数处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量提交给它；传统的C/C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供了找到所有数据所需的信息 另一种给函数提供所需信息的方法，即指定元素区间（range），这可以通过传递两个指针来完成：一个指针标识数组的开头，另一个指针标识数组的尾部 int sum_arr(const int begin, const int end); //声明 int sum = sum_arr(cookies, cookies+size); //调用 for (pt = begin; pt != end; pt++){ *pt; } //循环取值 指针和const可以用两种不同的方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值,第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。 int age =10 ;const int * p = &age; p为const不能通过p来修改值。当时age不是const，可以通过age修改。 指针和变量 是否可行 常规变量的地址赋给常规指针 可以 常规变量的地址赋给指向const的指针 可以 const变量的地址赋给指向const的指针 可以 const的地址赋给常规指针 不可以 注意：const只能防止修改指向的值，但是不能防止修改p的值 int sage=20; p=&amp;sage //ok 但事不能修改saged的值 下面这种声明使得p只能指向n,但是允许使用p 来修改n得值。 int n =1; int * const p = &n; 还可以声明const对象得const指针 int n =2 ; const int const p = &n; //p只能指向n,p还不能修改n得值。p和p均是const 函数和二维数组将二维数组作为参数的函数，必须牢记，数组名被视为其地址，因此，相应的形参是一个指针，就像一维数组一样。比较难处理的是如何正确地声明指针。 1234567891011int data[2][3]=&#123;&#123;1，2，3&#125;,&#123;4，5，6&#125;&#125;；int total =sum(data，2)；/* Date是一个数组名，里面含有3个元素，第一个元素本身四个数组，由3个int组成，因此data类型是由3个int组成的指针 声明如下：int sum(int (*ar)[3]，int size)；括号是必不可少的，因为下面的声明将声明一个由3个指向int的指针组成的数组，而不是由一个指向由3个int组成的数组的指针 还可以声明：int sum(int ar[][3]，int size)；ar是指针而不是数，它指向由3个int组成的数组。因此，指针类型指定了列数，这就是没有将列数作为独立的函数参数进行传递的原因*/ 函数和char字符串字符串由一系列字符组成，以空值字符结尾， 字符串与常规char数组之间的一个重要区别是，字符串有内置的结束字符，必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。 char指针(char *)类型字符串的三种表示方法 : char a[10] = “hello”; char * str = “hello” char数组；void fun1 = str(a) 用引号括起的字符串常量（也称字符串字面值）；void fun1 = str(“hello”) 被设置为字符串的地址的char指针。void fun1 = str(str) 函数无法返回一个字符串，但可以返回字符串的地址，这样做的效率更高。函数返回一个指针。该函数接受两个参数：一个字符和一个数字。函数使用new创建一个长度与数字参数相等的字符串，然后将每个元素都初始化为该字符。然后，返回指向新字符串的指针。 函数和结构体与数组不同，结构将其数据组合成单个实体或数据对象，该实体被视为一个整体。可以按值传递结构，就像普通变量那样。在这种情况下，函数将使用原始结构的副本。另外，函数也可以返回结构。与数组名就是数组第一个元素的地址不同的是，结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&amp;。在C语言和C++中，都使用符号&amp;来表示地址运算符；另外，C++还使用该运算符来表示引用变量。按值传递结构有一个缺点。如果结构非常大，则复制结构将增加内存要求，降低系统运行的速度。出于这些原因，许多C程序员倾向于传递结构的地址，然后使用指针来访问结构的内容。 传递和返回结构当结构比较小时，按值传递结构最合理 结构体 sum(结构体1 结构体2) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;struct time&#123; //定义结构体 int hours； int mins；&#125;；const int pre =60；time sum(time t1，time t2)； //定义函数 传递两个结构体，返回结构体void show_time(time t)； //显示结果int main()&#123; using namespace std； time time1=&#123;3,2&#125;; time time2=&#123;5,8&#125;; time result=sum(time1,time2); //引用函数 show_time(result); //显示结果 return 0；&#125;//结构体函数实现time sum(time t1,time t2)&#123; titme total; total.mins=(t1.mins+t2.mins)%pre; total.hours=t1.hours+t2.hours+(t1.mins+t2.mins)/pre; return total;&#125;//显示函数void show_time(time t)&#123; using namespace std; cout &lt;&lt; t.hours&lt;&lt;":"&lt;&lt;"t.mins"&lt;&lt;endl;&#125; 处理函数和结构体第二个方法这个例子将定义两个结构，用于表示两种不同的描述位置的方法，然后开发一个函数，将一种格式转换为另一种格式，并显示结果. 描述屏幕上的某个坐标使用x表示水平偏移量，使用y表示垂直偏移量(用坐标结构体表示位置)，另一种描述点的位置的方法是，指出它偏离原点的距离和方向（例如，东偏北40度）。数学家从正水平轴开始按逆时针方向度量角度距离和角度一起构成了极坐标(polar结构体)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cmath&gt;//坐标结构体struct rect&#123; double x; double y;&#125;;//polar结构体struct polar&#123; double distance; double angle;&#125;;/*创建一个显示polar内容的函数，角度约为：57.29577951形参的类型为polar。将一个polar结构传递给该函数时，该结构的内容将被复制到dapos结构中，函数随后将使用该拷贝完成工作*/void show_polar(polar dapos)&#123; using namespace std; const num=57.29577951; cout &lt;&lt; "distance="&lt;&lt;dapos.distance; cout &lt;&lt; "angle="&lt;&lt;dapos.angle*num; cout &lt;&lt;"show_polar over\n";&#125;//编写一个将直角坐标转换极坐标的函数。参数接受rect ,返回polar//数学知识用到头文件 cmath（毕达哥拉斯定力）polar rect_to_polar(rect xy)&#123; polor result; result.distance=sqrt(xy.x*xy.x+xy.y*xy.y); result.angle=atan2(xy.y,xy.x); return result;&#125;//mainint main()&#123; using namespace std; rect rp; polar pp; cout&lt;&lt;"输入x和y的值:"; //cin控制循环，如果输入不符合内容退出 while(cin &gt;&gt; rp.x &gt;&gt; rp.y)&#123; pp = rect_to_polar(rp); show_show_polar(pp); cout&lt;&lt;"下一组数据(q 退出)"; &#125; cout&lt;&lt;"over.\n"; return 0;&#125; 传递结构地址假设要传递结构的地址而不是整个结构以节省时间和空间，则需要重新编写前面的函数，使用指向结构的指针。 123456789101112131415161718192021222324252627282930313233//声明void rect_to_polar(const rect * pxy, polar* pda);void show_polar(const polar *pda);//重写调用时将指针传入，形参也修改指针，需要使用-&gt;间接成员void show_polar(const polar *pda)&#123; using namespace std; const num=57.29577951; cout &lt;&lt; "distance="&lt;&lt;pda-&gt;distance; cout &lt;&lt; "angle="&lt;&lt;pda-&gt;angle*num; cout &lt;&lt;"show_polar over\n";&#125;//重写转换 传入指针，也是结构体本身不是副本void rect_to_polar(const rect *xy, polar *pa)&#123; using namespace std; pa-&gt;distance=sqrt(xy-&gt;x*xy-&gt;x+xy-&gt;y*xy-&gt;y); pa-&gt;angle=atan2(xy-&gt;y,xy-&gt;x);&#125;//重写mainint main()&#123; using namespace std; rect rp; polar pp; cout&lt;&lt;"输入x和y的值:"; //cin控制循环，如果输入不符合内容退出 while(cin &gt;&gt; rp.x &gt;&gt; rp.y)&#123; rect_to_polar(&amp;rp, &amp;pp) show_show_polar(&amp;pp); cout&lt;&lt;"下一组数据(q 退出)"; &#125; cout&lt;&lt;"over.\n"; return 0;&#125; 函数和string对象tring对象与结构的更相似。例如，可以将一个结构赋给另一个结构，也可以将一个对象赋给另一个对象。可以将结构作为完整的实体传递给函数，也可以将对象作为完整的实体进行传递。如果需要多个字符串，可以声明一个string对象数组，而不是二维char数组。 除函数getline( )外，应像对待内置类型（如int）一样对待string对象。如果需要string数组，只需使用通常的数组声明格式即可：string list[size];数组list的每个元素都是一个string对象，可以像下面这样使用它:getline(cin,list[i]) 函数和array对象在C++中，类对象是基于结构的，因此结构编程方面的有些考虑因素也适用于类。例如，可按值将对象传递给函数，在这种情况下，函数处理的是原始对象的副本。另外，也可传递指向对象的指针，这让函数能够操作原始对象。 用array类，需要包含头文件array，而名称array位于名称空间std中。如果函数来显示expenses的内容，可按值传递expenses:show(xxx); 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;string&gt;const int season=4; //常量//四季的array 在函数声明之前，都可以使用const std::array&lt;std::string,season&gt; arr=&#123;"spring","summer","fall","winter"&#125;; void fill(std::array&lt;double,season&gt; *pa); //声明void show (std::array&lt;double,season&gt; da);int main()&#123; std::array&lt;double,season&gt; expenses; fill(&amp;expenses); //传入指针 show(expenses); //值传递 return 0;&#125;void fill(std::array&lt;double,season&gt; *pa)&#123; using namespace std; for (int i=0; i&lt;season;i++)&#123; cout &lt;&lt;"输入 "&lt;&lt;arr[i]&lt;&lt;" 收入："; //pa是一个arr对象的指针，而(*pa)[i]该对象的一个元素,由于运算符优先级的影响，其中的括号必不可少。 cin &gt;&gt; （*pa）[i]; &#125;&#125;void show (std::array&lt;double,season&gt; da)&#123; using namespace std; double total =0.0; for (int i=0; i&lt;season;i++)&#123; cout &lt;&lt; arr[i]&lt;&lt;":$"&lt;&lt;da[i]&lt;&lt;endl; total+=da[i]; &#125; cout&lt;&lt;"total :$"&lt;&lt;total&lt;&lt;endl;&#125; 递归函数调用自己称为递归。如果递归函数调用自己，则被调用的函数也将调用自己，这将无限循环下去，除非代码中包含终止调用链的内容。通常的方法将递归调用放在if语句中 1234567void fun (arglist)&#123; statments1; if (test) fun(arglist); statments2;&#125;test若为false，调用将终止 在需要将一项工作不断分为两项较小的、类似的工作时，递归非常有用。 函数指针与数据项相似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。 获取函数地址 只要使用函数名（后面不跟参数）。 fun1（fun）;//使fun1函数能够在其内部调用fun函数 fun1(fun()); //首先调用fun( )函数，然后将fun( )的返回值传递给fun1( )函数 声明函数指针 声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。 double fun(int) //函数类型 double(pt)(int); //指针声明 由于fun是函数，(\pt)也是函数，pt就是指针 pt=fun; //将相应函数的地址赋给指针 必须在声明中使用(pt)(int)指 pt是一个返回函数的指针。\pt(int) pt()是一个返回指针的函数。注意 函数声明和指针声明的返回值必须相同。 调用函数 double x= fun(10) //函数调用 double y = (*pt)(10);// 指针调用 double y = pt(5) ;//C++也允许像使用函数名那样使用pt 为何pf和（pf）等价呢？一种学派认为，由于pf是函数指针，而pf是函数，因此应将（*pf）( )用作函数调用。另一种学派认为，由于函数名是指向该函数的指针，指向函数的指针的行为应与函数名相似，因此应将pf( )用作函数调用使用。 函数指针示例：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;//函数声明double betsy(int);double pam(int);//函数指针作为参数的声明void estimate(int lines, double (*pt)(int));int main()&#123; using namespace std; int code; cout &lt;&lt; "how many lines of code do you need:"; cin &gt;&gt; code; cout &lt;&lt; "here's besty estimate:\n"; //调用函数指针参数 estimate(code, betsy); cout &lt;&lt; "here's pam estimate:\n"; estimate(code, pam); return 0;&#125;double betsy(int lns)&#123; return 0.05 * lns;&#125;double pam(int lns)&#123; return 0.03 * lns + 0.0004 * lns * lns;&#125;void estimate(int lines, double (*pt)(int))&#123; using namespace std; cout &lt;&lt; "lines value:" &lt;&lt; lines&lt;&lt;"\n"; cout &lt;&lt; (*pt)(lines) &lt;&lt; " hour(s)\n";&#125;-----------------------------------------------------how many lines of code do you need:100here's besty estimate:lines value:1005 hour(s)here's pam estimate:lines value:1007 hour(s) 探讨函数指针const double * f1 (const double arr[], int n) const double * f2 (const double [], int); const double f3 (const double , int); 上面三个函数原型表示的相同，因为可以省略标识符，const double * arr 和 const double[]相同。 const double (p1) (const double *, int); 指针的声明，指向上面三个函数原型 auto p2 =f2; //C++11的类型自动推导也可以 (p1)(av,3)和p2(av,3)都是指向调用函数，返回值是f1或f2的返回值。类型 const double (double值的地址)。如果需要取地址存储的实际值，需要 用*(*p1)(av,3)或*p2(av,3). const double (pt[3]) (const double *,int)={f1,f2,f3}; 以上语句是使用函数指针数组存储上面三个函数，pt是一个包含三个元素的数组，而加上表示就是pt是一个包含三个指针的数组， (const double ,int)表示每个指针指向的类型函数。const double *是返回值类型。这里不能使用auto，自动类型推断只能用于单值初始化，而不能用于初始化列表(可以 auto pt1 =pt)。 初始化：const double px = pt [0] (av,3) 或 （pt[1]）(av,3) 取值： double x = pt[0] (av,3); 或 (*pt[1])(av,3) 使用typedef简化 除auto外，C++还提供了其他简化声明的工具：typedef(创建类型别名) 问答 使用函数的三个步骤 声明 定义 调用 编写一个参数(int数组 长度 int值)，并将数组所有的元素设置这int值的函数 12345void fun (int arr[], int size, int value)&#123; for (int i = 0; i&lt;size;i++)&#123; arr[i] = value; &#125;&#125; 编写一个参数(数组第一个元素指针，最后一个元素指针，int值)，并把数组值赋给int的函数 12345void fun(int * begin, int * end, int value)&#123; for (int *p =begin; p != end;p++)&#123; p*=value; &#125;&#125; 不对类型为基本类型的函数参数使用const const 限定用于指针，房子指向原始的数据被修改，因为c++函数传递的为基本类型是按值传递。使用的副本，保护原始数据 函数原型 int fun(char * str, char c1,char c2)。c1替换c2 1234567891011int fun (char *str, char c1, char c2)&#123; int count =0 ; //返回替换次数 while(*str)&#123; //‘\0’ if (*str==c1)&#123; *str =c2; count++; &#125; str++； //指针++ &#125; return count;&#125; 表达式*”abc”和”def”[2]表达什么 “abc”解释为第一个元素的地址，用*获取值也就是a;”def”为第一个元素地址，“def”[2]我第二个元素的值e.字符串常量的值与数组相同 结构的按值传递和传递地址利弊 按值传递，只需要传递结构名，这样自动保护原始数据，当时这是比较浪费时间和内存的；传递地址需要使用&amp;结构名，但是不能保护数据，除非对函数使用了const。按值传递可以使用常规的结构成员表示法(.)按指针传递必须使用间接成员运算符（-&gt;） 函数fun()返回类型为int，参数（const char指针作为参数并返回int值编）写原型 int fun(int (pt)(const char )); 结构体如下，编写函数 12345678910111213141516171819//结构体struct applicant&#123; char name[30]; int credit_ratings[3];&#125;;//1. 写一个函数，它将application结构作为参数，并显示该结构的内容，void show (applicant ap)&#123; cout &lt;&lt;ap.name &lt;&lt;endl; for (int i=0;i&lt;3;i++)&#123; cout &lt;&lt; ap.credit_ratings[i]&lt;&lt;endl; &#125;&#125;//2.编写一个函数，它将application结构的地址作为参数，并显示该参数指向的结构的内容（地址）void show (const applicant * pa)&#123; cout &lt;&lt;pa-&gt;name&lt;&lt;endl; for(int i=0; i&lt;3;i++)&#123; cout&lt;&lt;pa-&gt;credit_ratings[i]&lt;&lt;endl; &#125;&#125; 函数f1()和f2()的原型如下： 123456789void f1(applicant * a);const char * f2(const applicant *a1, const applicant *a2,);/* 将p1和p2分别声明为指向f1和f2的指针；将ap声明为一个数组，它包含5个类型与p1相同的指针；将pa声明为一个指针，它指向的数组包含10个类型与p2相同的指针。使用typedef来帮助完成这项工作。*/typedef void (*p_f1)(applicant *);p_f1 p1 = f1;typedef const char *(*p_f2)(const applicant *,const applicant *);p_f2 p2 = f2;p_f1 ap[5];p_f2 (*pa)[10]; 代码 输入最多10个数(可以小10)并存入数组中并回显，在求平均成绩.使用三个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;unsigned input(double num[], unsigned size)&#123; double tmp; unsigned numSize = 0; while (numSize &lt; size &amp;&amp; cin &gt;&gt; tmp &amp;&amp; tmp != -1) &#123; num[numSize++] = tmp; &#125; return numSize;&#125;void show(double numList[], unsigned size)&#123; for (unsigned i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; numList[i] &lt;&lt; ' '; &#125;&#125;double aver(double numList[], unsigned size)&#123; double sum = 0; for (unsigned i = 0; i &lt; size; ++i) &#123; sum += numList[i]; &#125; return (sum / size);&#125;int main(void)&#123; const unsigned k_size = 10; double numList[k_size]; cout &lt;&lt; "enter 10 num, -1 over:"; unsigned inputSize = input(numList, k_size); cout &lt;&lt; "show list:"; show(numList, inputSize); cout &lt;&lt; endl; cout &lt;&lt; "ave=:" &lt;&lt; aver(numList, inputSize); cout &lt;&lt; endl; return 0;&#125; 又个box结构体，编写函数按值传递结构，并显示每个成员的值，用函数传递box地址，并将成员volume设置为三维长度乘积。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;struct Tbox&#123; char szMaker[40]; float height; float width; float length; float volume;&#125;;void show(Tbox box)&#123; cout &lt;&lt; box.szMaker &lt;&lt; '\t' &lt;&lt; box.height &lt;&lt; '\t' &lt;&lt; box.width &lt;&lt; '\t' &lt;&lt; box.length;&#125;float calc_volume(Tbox *p)&#123; return (p-&gt;volume = p-&gt;height * p-&gt;width * p-&gt;length);&#125;int main(void)&#123; Tbox box = &#123;"boxbig", 12, 10, 6, 0&#125;; show(box); cout &lt;&lt; endl; cout &lt;&lt; calc_volume(&amp;box); cout &lt;&lt; endl; return 0;&#125; 双色球中一等奖几率(33选6 16选1) 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;long double cal(unsigned numbers, unsigned picks)&#123; long double pro = 1.0; while (picks &gt; 0) &#123; pro *= 1.0 * numbers / picks; --numbers; --picks; &#125; return pro;&#125;int main(void)&#123; long double pro = cal(33, 6) * cal(16, 1); cout &lt;&lt; fixed &lt;&lt; pro &lt;&lt; "\\1"; cout &lt;&lt; endl; return 0;&#125; 递归求阶层 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;unsigned long long calc_factorial_less_equ_to_20(unsigned long long n)&#123; return ((0 == n) ? 1 : n * calc_factorial_less_equ_to_20(n - 1));&#125;int main(void)&#123; while (true) &#123; cout &lt;&lt; "输入一个不超过20的非负整数："; unsigned long long n; cin &gt;&gt; n; if (!cin || n &gt; 20) &#123; // 采用递归实现的阶乘算法最多只能计算20以内的阶乘，否则将导致溢出 break; &#125; cout &lt;&lt; n &lt;&lt; "的阶乘为：" &lt;&lt; calc_factorial_less_equ_to_20(n) &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 编写程序，使用函数Fill_array( )将一个double数组的名称和长度作为参数，用户输入double值，如果输入非法，或溢出停止，返回输入多少，Show_array( )将数组名称和长度作为参数，显示该数组，Reverse-array( )将数组的名称和长度作为参数，并将存储在数组中的值的顺序反转。反转数组中除第一个和最后一个元素之外的所有元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;const int Max = 5;double *fill_array(double *pBeg, const double *pEnd)&#123; using namespace std; double temp; int i = 0; while (pBeg &lt; pEnd) &#123; cout &lt;&lt; "Enter value #" &lt;&lt; i++ &lt;&lt; ": "; cin &gt;&gt; temp; if (!cin) // bad input &#123; cin.clear(); while (cin.get() != '\n') continue; cout &lt;&lt; "Bad input; input process terminated.\n"; break; &#125; else if (temp &lt; 0) break; *pBeg = temp; ++pBeg; // signal to terminate &#125; return pBeg;&#125;// the following function can use, but not alter,// the array whose address is arvoid show_array(const double *pBeg, const double *pEnd)&#123; using namespace std; for (int i = 0; pBeg &lt; pEnd; ++pBeg) &#123; cout &lt;&lt; "Property #" &lt;&lt; (i + 1) &lt;&lt; ": $"; cout &lt;&lt; *pBeg &lt;&lt; endl; &#125;&#125;// multiplies each element of ar[] by rvoid revalue(double r, double *pBeg, const double *pEnd)&#123; while (pBeg &lt; pEnd) &#123; *pBeg *= r; ++pBeg; &#125;&#125;int main()&#123; using namespace std; double properties[Max]; double *pArrEnd = fill_array(properties, properties + Max); show_array(properties, pArrEnd); if (pArrEnd - properties &gt; 0) &#123; cout &lt;&lt; "Enter revaluation factor: "; double factor; while (!(cin &gt;&gt; factor)) // bad input &#123; cin.clear(); while (cin.get() != '\n') continue; cout &lt;&lt; "Bad input; Please enter a number: "; &#125; revalue(factor, properties, pArrEnd); show_array(properties, pArrEnd); &#125; cout &lt;&lt; "Done.\n"; cin.get(); cin.get(); return 0;&#125; 修改fill_array( )函数不返回实际读取了多少个数字，而是返回一个指针，该指针指向最后被填充的位置；其他的函数可以将该指针作为第二个参数，以标识数据结尾。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;const int Max = 5;int fill_array(double *pBeg, const double *pEnd)&#123; using namespace std; double temp; int i = 0; while (pBeg &lt; pEnd) &#123; cout &lt;&lt; "Enter value #" &lt;&lt; i++ &lt;&lt; ": "; cin &gt;&gt; temp; if (!cin) // bad input &#123; cin.clear(); while (cin.get() != '\n') continue; cout &lt;&lt; "Bad input; input process terminated.\n"; break; &#125; else if (temp &lt; 0) break; *pBeg = temp; ++pBeg; // signal to terminate &#125; return i;&#125;// the following function can use, but not alter,// the array whose address is arvoid show_array(const double *pBeg, const double *pEnd)&#123; using namespace std; for (int i = 0; pBeg &lt; pEnd; ++pBeg) &#123; cout &lt;&lt; "Property #" &lt;&lt; (i + 1) &lt;&lt; ": $"; cout &lt;&lt; *pBeg &lt;&lt; endl; &#125;&#125;// multiplies each element of ar[] by rvoid revalue(double r, double *pBeg, const double *pEnd)&#123; while (pBeg &lt; pEnd) &#123; *pBeg *= r; ++pBeg; &#125;&#125;int main()&#123; using namespace std; double properties[Max]; int size = fill_array(properties, properties + Max); show_array(properties, properties + size); if (size &gt; 0) &#123; cout &lt;&lt; "Enter revaluation factor: "; double factor; while (!(cin &gt;&gt; factor)) // bad input &#123; cin.clear(); while (cin.get() != '\n') continue; cout &lt;&lt; "Bad input; Please enter a number: "; &#125; revalue(factor, properties, properties + size); show_array(properties, properties + size); &#125; cout &lt;&lt; "Done.\n"; cin.get(); cin.get(); return 0;&#125; 使用const char 数组存储表示季度名称的字符串，并使用double数组存储开支。使用const char 数组存储表示季度名称的字符串，并使用一个结构，该结构只有一个成员——一个用于存储开支的double数组。这种设计与使用array类的基本设计类似.（写两个版本） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//1.#include &lt;iostream&gt;#include &lt;string&gt;// constant dataconst int Seasons = 4;const char *Snames[] = &#123;"Spring", "Summer", "Fall", "Winter"&#125;;void fill(double *pa)&#123; using namespace std; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; "Enter " &lt;&lt; Snames[i] &lt;&lt; " expenses: "; cin &gt;&gt; pa[i]; &#125;&#125;void show(double da[])&#123; using namespace std; double total = 0.0; cout &lt;&lt; "\nEXPENSES\n"; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; Snames[i] &lt;&lt; ": $" &lt;&lt; da[i] &lt;&lt; endl; total += da[i]; &#125; cout &lt;&lt; "Total Expenses: $" &lt;&lt; total &lt;&lt; endl;&#125;int main()&#123; double expenses[Seasons]; fill(expenses); show(expenses); return 0;&#125;//2.#include &lt;iostream&gt;#include &lt;string&gt;// constant dataconst int Seasons = 4;const char *Snames[] = &#123;"Spring", "Summer", "Fall", "Winter"&#125;;struct TData&#123; double arr[Seasons];&#125;;void fill(TData *pData)&#123; using namespace std; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; "Enter " &lt;&lt; Snames[i] &lt;&lt; " expenses: "; cin &gt;&gt; pData-&gt;arr[i]; &#125;&#125;void show(TData data)&#123; using namespace std; double total = 0.0; cout &lt;&lt; "\nEXPENSES\n"; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; Snames[i] &lt;&lt; ": $" &lt;&lt; data.arr[i] &lt;&lt; endl; total += data.arr[i]; &#125; cout &lt;&lt; "Total Expenses: $" &lt;&lt; total &lt;&lt; endl;&#125;int main()&#123; TData expenses; fill(&amp;expenses); show(expenses); return 0;&#125; 联系处理数组和结构体函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;const int SLEN = 30;struct student&#123; char fullname[SLEN]; char hobby[SLEN]; int ooplevel;&#125;;// getinfo() has two arguments: a pointer to the first element of// an array of student structures and an int representing the// number of elements of the array. The function solicits and// stores data about students. It terminates input upon filling// the array or upon encountering a blank line for the student// name. The function returns the actual number of array elements// filled.int getinfo(student pa[], int n)&#123; int num_array_elem = n; char tmp[SLEN]; for (unsigned i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; "输入姓名："; cin.getline(tmp, SLEN); bool blank_line = true; for (unsigned j = 0; j &lt; strlen(tmp); ++j) &#123; if (!isspace(tmp[j])) &#123; blank_line = false; break; &#125; &#125; if (blank_line) &#123; num_array_elem = i; break; &#125; strcpy(pa[i].fullname, tmp); cout &lt;&lt; "输入兴趣："; cin.getline(pa[i].hobby, SLEN); cout &lt;&lt; "输入面向对象程序设计能力的级别："; cin &gt;&gt; pa[i].ooplevel; cin.get(); &#125; return (num_array_elem);&#125;// display1() takes a student structure as an argument// and displays its contentsvoid display1(student st)&#123; cout &lt;&lt; st.fullname &lt;&lt; '\t' &lt;&lt; st.hobby &lt;&lt; '\t' &lt;&lt; st.ooplevel &lt;&lt; endl;&#125;// display2() takes the address of student structure as an// argument and displays the structure’s contentsvoid display2(const student *ps)&#123; cout &lt;&lt; ps-&gt;fullname &lt;&lt; '\t' &lt;&lt; ps-&gt;hobby &lt;&lt; '\t' &lt;&lt; ps-&gt;ooplevel &lt;&lt; endl; ;&#125;// display3() takes the address of the first element of an array// of student structures and the number of array elements as// arguments and displays the contents of the structuresvoid display3(const student pa[], int n)&#123; for (unsigned i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; pa[i].fullname &lt;&lt; '\t' &lt;&lt; pa[i].hobby &lt;&lt; '\t' &lt;&lt; pa[i].ooplevel &lt;&lt; endl; &#125;&#125;int main()&#123; cout &lt;&lt; "输入班级人数："; int class_size; cin &gt;&gt; class_size; while (cin.get() != '\n') continue; student *ptr_stu = new student[class_size]; int entered = getinfo(ptr_stu, class_size); for (int i = 0; i &lt; entered; i++) &#123; display1(ptr_stu[i]); display2(&amp;ptr_stu[i]); &#125; display3(ptr_stu, entered); delete[] ptr_stu; cout &lt;&lt; "完毕\n"; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*calculate( )的函数，它接受两个double值和一个指向函数的指针，而被指向的函数接受两个double参数，并返回一个double值。calculate( )函数的类型也是double，并返回被指向的函数使用calculate( )的两个double参数计算得到的值。例如，假设add( )函数的定义如下：double add (double a,double b)&#123; return a+b;&#125;代码中的函数调用将导致calculate( )把2.5和10.4传递给add( )函数，并返回add( )的返回值（12.9）double q =calculate(2.5, 10.4, add);调用上述两个函数和至少另一个与add( )类似的函数。该程序使用循环来让用户成对地输入数字。对于每对数字，程序都使用calculate( )来调用add( )和至少一个其他的函数.提示：指针数组的声明方式。，double (*pf[3])(double,double);*/#include &lt;iostream&gt;using namespace std;typedef double (*TPfun)(double x, double y);void calculate(double x, double y, TPfun fun[], unsigned num_of_funs)&#123; for (unsigned i = 0; i &lt; num_of_funs; ++i) &#123; cout &lt;&lt; fun[i](x, y) &lt;&lt; endl; &#125;&#125;doubleadd(double x, double y)&#123; cout &lt;&lt; "加法操作结果："; return (x + y);&#125;doublesub(double x, double y)&#123; cout &lt;&lt; "减法操作结果："; return (x - y);&#125;int main(void)&#123; TPfun fun[] = &#123;add, sub&#125;; while (true) &#123; cout &lt;&lt; "输入两个数："; double x, y; cin &gt;&gt; x &gt;&gt; y; if (!cin) &#123; break; &#125; calculate(x, y, fun, sizeof(fun) / sizeof(fun[0])); &#125; cout &lt;&lt; endl; return (0);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础知识02]]></title>
    <url>%2F2019%2F05%2F21%2FC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8602%2F</url>
    <content type="text"><![CDATA[第二章：数据结构 简单变量变量名 在名称中只能使用字母字符、数字和下划线（_） 名称的第一个字符不能是数字 区分大写字符与小写字符 不能将C++关键字用作名称 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。 C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制 整型整型就是没有小说部分的数字。char、short、int、long和long long (C++11)每种类型都分有符号版本和无符号版本。检查操作系统中整形的最大长度使用“sizeof”函数。climits头文件常用常量列表： 常量 表示 常量 表示 CHAR_BIT char的位数 CHAR_MAX char的最大值 CHAR_MIN char的最小值 SCHAR_MAX signed char的最大值 SCHAR_MIN signed char的最小值 UCHAR_MAX unsigned char的最大值 SHRT_MAX short的最大值 SHRT_MIN short的最小值 USHRT_MAX unsigned short的最大值 INT_MAX int的最大值 INT_MIN int的最小值 UNIT_MAX unsigned int的最大值 LONG_MAX long的最大值 LONG_MIN long的最小值 ULONG_MAX unsigned long的最大值 LLONG_MAX long long的最大值 LLONG_MIN long long的最小值 ULLONG_MAX unsigned long long的最大值 无符号类型unsigned short/int…假如short表示的范围为−32768到+32767，则无符号版本的表示范围为0-65535，仅当数值不回为负时才使用无符号类型。如果无符号类型为0时再减1，会变成65535，如果超越了限制就会从另一端取值 char类型为存储字母和数值（ASCII码对照表）在默认情况，char不是有符号也不是没符号，一般存储ASCII码 bool类型C++将非零值解释为true，将零解释为false constC++有一种更好的处理符号常量的方法，这种方法就是使用const关键字来修改变量声明和初始化 const int MOnths =12 常量被初始化后，其值就被固定了，编译器将不允许再修改该常量的值两个约定： 将名称的首字母大写，以提醒是个常量 将整个名称大写，使用#define创建常量时通常使用这种约定 浮点数浮点数能够表示带小数部分的数字。C++也有3种浮点类型：float、double和long double注意：1.0也是浮点数 类型转换将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换；表达式中包含不同的类型时，C++将对值进行转换；将参数传递给函数时，C++将对值进行转换.讲一个值赋给取值范围更大的类型不回有什么问题(float-&gt;double int-&gt;long)。将0赋给bool变量时，将被转换为false；而非零值将被转换为true。 潜在数值转换问题： double转换为float:精度（有效数位）降低，值可能超出目标类型的取值范围 浮点类型转换为整型:小数部分丢失，原来的值可能超出目标类型的取值范围 较大的整型转换为较小的整型:原来的值可能超出目标类型的取值范围，通常只复制右边的字节 表达式转换：当同一个表达式中包含两种不同的算术类型时，C++将执行两种自动转换，首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。自动转换：在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int，这些转换被称为整型提升。传递参数时的转换：传递参数时的类型转换通常由C++函数原型控制，C++将对char和short类型（signed和unsigned）应用整型提升。另外，为保持与传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double。强制类型转换：C++还允许通过强制类型转换机制显式地进行类型转换，强制类型转换不会修改变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值。 （typeName）value 或 typeName(value) 第一种来自C，第二种时C++C++还引入了4个强制类型转换运算符,static_cast&lt;&gt;可用于将值从一种数值类型转换为另一种数值类型,运算符static_cast&lt;&gt;比传统强制类型转换更严格 static_cast（value） C++11的auto声明C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了auto的含义。auto是一个C语言关键字，但很少使用，在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同 auto n = 100 //intauto x = 1.5 //double 问答C++数据类型多样化意义： 可以根据需求选择最合适的数据类型。 声明和初始化 short num1=80unsigned int num2 =999 //无符号unsigned long num3 =300000000 //注意不能使用int C++放溢出 C++没有提供放置超过整形限制的功能，但是可以使用头文件“climits”来获取限制范围，选择合适的类型。 寻找编码的字符 char c = 65；cout&lt;&lt;c&lt;&lt;endl; //Acout.put(char(65));//Acout&lt;&lt;char(65)&lt;&lt;endl;cout&lt;&lt;(char)65&lt;&lt;endl; 强制类型转换(x1,x2位double) int(x1+x2) //先将x1+x2计算，在转换整数int(x1)+int(x2) //先将x1,x2转换为整数，再相加。 代码1.设置一个常量作，用户输入身高，转换为英尺1234567891011121314151617#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const int k_factorFeetToInch = 12; // 1英尺 = 12英寸 int inches; cout &lt;&lt; "输入身高，__英寸："; cin &gt;&gt; inches; //整除 取余 cout &lt;&lt; "也就" &lt;&lt; inches / k_factorFeetToInch &lt;&lt; "英尺又" &lt;&lt; inches % k_factorFeetToInch &lt;&lt; "英寸"; cout &lt;&lt; endl; return (0);&#125; 2.用户(英尺 英寸)方式输入身高，用已磅为单位输入体重，计算体重指数。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; double height, weight, bmi; // 输入身高以英尺和英寸为单位 int feet, inches; cout &lt;&lt; "输入身高，__英尺又__英寸："; cin &gt;&gt; feet &gt;&gt; inches; // 获得以英寸为单位的身高 const int k_factorFeetToInches = 12; // 1英尺 = 12英寸 height = feet * k_factorFeetToInches + inches; // 获得以米为单位的身高 const double k_factorInchesToMeters = 0.0254; // 1英寸 = 0.0254米 height = height * k_factorInchesToMeters; // 输入体重以磅为单位 int pounds; cout &lt;&lt; "输入以磅为单位的体重："; cin &gt;&gt; pounds; // 获得以千克为单位的体重 const double k_factorPoundsToKilograms = 1 / 2.2; // 1磅 = 1/2.2千克 weight = pounds * k_factorPoundsToKilograms; // 计算BMI bmi = weight / (height * height); // 显示BMI cout &lt;&lt; "BMI：" &lt;&lt; bmi &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 3.用户输入秒没然后已天、小时、分钟、秒显示此时间段，12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const long k_factorMinuteToSecond = 60; const long k_factorHourToMinute = 60; const long k_factorDayToHour = 24; cout &lt;&lt; "Enter the number of seconds: "; long secondsTotal; cin &gt;&gt; secondsTotal; long seconds = secondsTotal % k_factorMinuteToSecond; long minutesTotal = secondsTotal / k_factorMinuteToSecond; long minutes = minutesTotal % k_factorHourToMinute; long hoursTotal = minutesTotal / k_factorHourToMinute; long hours = hoursTotal % k_factorDayToHour; long days = hoursTotal / k_factorDayToHour; cout &lt;&lt; secondsTotal &lt;&lt; " seconds = " &lt;&lt; days &lt;&lt; " days, " &lt;&lt; hours &lt;&lt; " hours, " &lt;&lt; minutes &lt;&lt; " minutes, " &lt;&lt; seconds &lt;&lt; " seconds"; cout &lt;&lt; endl; return (0);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础知识04]]></title>
    <url>%2F2019%2F05%2F21%2FC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8604%2F</url>
    <content type="text"><![CDATA[第四章：循环和关系表达式 for循环 设置初始值 执行测试，看看循环是否应当继续进行 执行循环操作 更新用于测试的值 C++循环设计中包括了这些要素，很容易识别。初始化、测试和更新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表达式，彼此由分号隔开。控制部分后面的语句叫作循环体，只要测试表达式为true，它便被执行 for(initialization;test-expression;update-expression){body} initialization:初始化的值，只执行一次，用其变量计算循环周期test-expression：测试表达式，决定循环体是否被执行。update-expression：更新表达式，在每轮循环结束时执行，此时循环体已经执行完毕1234567891011121314151617181920212223242526/**计算阶乘**/#include&lt;iostream&gt;const int SIZE = 10;int main()&#123; long long factorials[SIZE]; //定义一个数组 factorials[1]=factorials[0]=1LL; // for (int i = 2; i &lt; SIZE; i++) &#123; factorials[i]=i*factorials[i-1]; &#125; for (int i = 0; i &lt; SIZE; i++)&#123; std::cout&lt;&lt;i&lt;&lt;"! = "&lt;&lt;factorials[i]&lt;&lt;std::endl; &#125; return 0;&#125;--------------------------------------------0! = 11! = 12! = 23! = 64! = 245! = 1206! = 7207! = 50408! = 403209! = 362880 “++i”与“i++”在一条语句中（即两个分号之间)，++i 被当成(i+1)来计算，i++被当成i来计算对于for循环来说，前++和后++对结果是没有影响，但是执行效率上会不同前++：将值+1,然后返回结果。后++：首先复制一个副本，将其+1，然后将赋值的副本返回(效率略差)。指针的递增/减 *++pt:先将++应用于pt（因为++位于的右边），然后将应用于被递增后的pt ++*pt：先取得pt指向的值，然后将这个值加1 (*pt)++:圆括号指出，首先对指针解除引用，得到值，然后，运算符++将值+1，pt指向不变 *pt++:后缀运算符++的优先级更高，这意味着将运算符用于pt，而不是*pt,因此对指针递增。然而后缀运算符意味着将对原来的地址（&amp;arr[2]）而不是递增后的新地址解除引用，因此*pt++的值为原地址，但该语句执行完毕后，pt的值将为+1的地址。12345678double arr[5]=&#123;11.11,22.22,33.33,44.44,55.55&#125;;double *pt =arr; //11.11++pt; //22.22*++pt; //arr[2],33.33++*pt; //arr[2],34.33(*pt)++; //arr[2],35.33*pt++; //35.33*pt; //44.44 while循环while循环是没有初始化和更新部分的for循环，它只有测试条件和循环体 ` while(test-condition){body} 程序计算圆括号内的测试条件（test-condition）表达式。如果该表达式为true，则执行循环体中的语句。循环获取字符串123456789101112131415161718192021222324#include &lt;iostream&gt;const int SIZE = 20;int main()&#123; using namespace std; char name[SIZE]; cout &lt;&lt; "输入一个字符串ASCII:"; cin &gt;&gt; name; int i = 0; while (name[i] != '\0') //while (name[i]) &#123; cout &lt;&lt; name[i] &lt;&lt; ": " &lt;&lt; int(name[i]) &lt;&lt; endl; i++; &#125; return 0;&#125;--------------------------------输入一个字符串ASCII:ABCDEFA: 65B: 66C: 67D: 68E: 69F: 70 可以这样修改while行：while (name[i])经过这种修改后，程序的工作方式将不变。这是由于name[i]是常规字符，其值为该字符的编码—非零值或true 延时循环while循环可用于写延时循环，C++库中有一个函数有助于完成这样的工作。这个函数名为clock( )，返回程序开始执行后所用的系统时间。这有两个复杂的问题：首先，clock( )返回时间的单位不一定是秒；其次，该函数的返回类型在某些系统上可能是long，在另一些系统上可能是unsigned long或其他类型。但头文件ctime（较早的实现中为time.h）提供了这些问题的解决方案。首先，它定义了一个符号常量—CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数。因此，将系统时间除以这个值，可以得到秒数。或者将秒数乘以CLOCK_PER_SEC，可以得到以系统时间单位为单位的时间。其次，ctime将clock_t作为clock( )返回类型的别名（参见本章后面的注释“类型别名”），这意味着可以将变量声明为clock_t类型，编译器将把它转换为long、unsigned int或适合系统的其他类型12345678910111213141516#include &lt;iostream&gt;#include &lt;ctime&gt;int main()&#123; using namespace std; cout &lt;&lt; "输入系统休息时间，秒为单位："; float secs; cin &gt;&gt; secs; clock_t delay = secs * CLOCKS_PER_SEC; cout &lt;&lt; "staring\a\n"; clock_t start = clock(); while (clock() - start &lt; delay) ; cout &lt;&lt; "over!!! \a\n"; return 0;&#125; do while循环这种循环将首先执行循环体，然后再判定测试表达式，决定是否应继续执行循环。如果条件为false，则循环终止；否则，进入新一轮的执行和测试。这样的循环通常至少执行一次，因为其程序流必须经过循环体后才能到达测试条件 do{body} while(test-expression) 增强for循环C++11新增了一种循环：基于范围（range-based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每个元素执行相同的操作123456789double price[5]=&#123;1.1,2.2,3.3,4.4,5.5&#125;;for (double x : price)&#123; cout&lt;&lt; x &lt;&lt;std::endl; //遍历&#125;-------------------------------------//修改元素值.符号&amp;表明x是一个引用变量for (double &amp;x : price)&#123; X=x*0.8 &#125; 循环文本输入使用cin输入要使用循环来读取来自键盘的文本输入，需要选择某个特殊字符—有时被称为哨兵字符，将其作为停止标记 while(ch != ‘#’) //停止字符为“#” cin.get(char)输入通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符，成员函数cin.get(ch)读取输入中的下一个字符（即使它是空格），并将其赋给变量ch12345678//此程序不完美：一个值放在ch变量中，这意味着将修改该变量的值。//在C语言中，要修改变量的值，必须将变量的地址传递给函数char ch;cin.get(ch); //获取第一个输入的字符while(ch!='#')&#123; cout&lt;&lt;ch; cin.get(ch); //使用cin.get &#125; 文件尾的条件文件尾（EOF）。C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序，检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过成员函数eof( )来查看eofbit是否被设置；如果检测到EOF，则cin.eof( )将返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1，则fail( )成员函数返回true，否则返回false。注意，eof( )和fail( )方法报告最近读取的结果；也就是说，它们在事后报告，而不是预先报告。因此应将cin.eof( )或cin.fail( )测试放在读取后，程序清单5.18中的设计体现了这一点。它使用的是fail( )，而不是eof( )，因为前者可用于更多的实现中。whindows “Ctrl+Z和Enter”mac “Ctrl+D” while(cin.fail()==false) //检测EOF cin.clear( )方法可能清除EOF标记，使输入继续进行 cin.get(ch)和cin.get()区别传递输入字符的方式：cin.get(ch)-&gt;赋给参数chcin.get()-&gt;将函数返回值赋给ch 用于字符输入时函数的返回值cin.get(ch)-&gt;istream对象（执行bool转换后为true）cin.get()-&gt;int类型的字符编码 到达EOF时函数的返回值cin.get(ch)-&gt;istream对象（执行bool转换后为false）cin.get()-&gt;EOF 二维数组和嵌套循环初始化：1234int arrTwo[2][3]=&#123; //两行三列 ｛1,2,3｝， ｛4,5,6｝&#125;； 使用二维数组：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;const int X = 4;const int Y = 3;int main()&#123; using namespace std; /* //char数组的数组 char city[X][25]=&#123; "BJ", "HN", "GZ", "TJ" &#125;; */ //指针数组初始化为一组字符串常量 const char *city[X] = &#123;"BJ", "HN", "GZ", "TJ"&#125;; int temp[Y][X] = &#123; &#123;96, 97, 98,99&#125;, &#123;88, 89, 87,88&#125;, &#123;71, 72, 73,70&#125;&#125;; cout &lt;&lt; "-------------------------------\n"; for (int i = 0; i &lt; X; ++i) &#123; cout &lt;&lt; city[i] &lt;&lt; ":\t"; for (int j = 0; j &lt; Y; j++) &#123; cout &lt;&lt; temp[j][i] &lt;&lt; "\t"; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;---------------------------BJ: 96 88 71HN: 97 89 72GZ: 98 87 73TJ: 99 88 70 程序使用了一个嵌套循环。这一次，循环的顺序相反，将列循环放在外面，将行循环放在内面,它还采用了C++常用的做法，将一个指针数组初始化为一组字符串常量,也就是说，将city声明为一个char指针数组。这使得每个元素（如city [0]）都是一个char指针，可被初始化为一个字符串的地址。如果希望字符串是可修改的，则应省略限定符const 问答入口循环和出口循环 for和while属于入口循环，先判断条件。do while是出口循环，至少执行一次循环体。 int j=5; while(++j &lt;9){ cout&lt;&lt;j++&lt;&lt;endl;}打印什么 6 8 打印1、2、4、8、16、32、64的for循环，每轮循环都将计数变量的值乘以2。 for(int num=1; num&lt;=64; num*=2) int x =(1,024)是否有效 有效，表示1和024，用逗号连接，值为右侧表达式的值。24，八进制20 int y =1,024是否有效 有效,y=1 在查看输入方面，cin &gt;&gt;ch同cin.get(ch)和ch=cin.get( )有什么不同 cin&gt;&gt;ch将跳过空格、换行符和制表符，其他读取这些符号 代码1.用户输入两个整数，该程序计算这两个整数之间的整数和1234567891011121314151617181920212223242526#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; int nLowerBound, nUpperBound; cout &lt;&lt; "输入区间："; cin &gt;&gt; nLowerBound &gt;&gt; nUpperBound; int nSum = 0; for (int i = nLowerBound; i &lt;= nUpperBound; ++i) &#123; nSum += i; &#125; cout &lt;&lt; "[" &lt;&lt; nLowerBound &lt;&lt; ", " &lt;&lt; nUpperBound &lt;&lt; "]区间总和为" &lt;&lt; nSum; cout &lt;&lt; endl; return (0);&#125;--------------------------------输入区间：2 9[2, 9]区间总和为44 2.使用array对象（而不是数组）和long double（而不是long long）编写计算100!的值123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;array&gt;using std::array;using std::cin;using std::cout;using std::endl;int main(void)&#123; const unsigned k_uSize = 101; array&lt;long double, k_uSize&gt; factorials; factorials[1] = factorials[0] = 1.0L; for (unsigned i = 2; i &lt; k_uSize; ++i) &#123; factorials[i] = i * factorials[i - 1]; &#125; for (unsigned i = 0; i &lt; k_uSize; ++i) &#123; cout &lt;&lt; i &lt;&lt; "! = " &lt;&lt; factorials[i] &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 3.编写一个要求用户输入数字的程序。每次输入后，程序都将报告到目前为止，所有输入的累计和。当用户输入0时，程序结束12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const int k_nEndFlag = 0; int nSum = 0; int nTmp; cout &lt;&lt; "输入数字："; do &#123; cin &gt;&gt; nTmp; nSum += nTmp; &#125; while (k_nEndFlag != nTmp); cout &lt;&lt; "总和为：" &lt;&lt; nSum; cout &lt;&lt; endl; return (0);&#125;--------------------输入数字：120总和为：3 4.Daphne以10%的单利投资了100美元。也就是说，每一年的利润都是投资额的10%，即每年10美元：(利息 = 0.10×原始存款)而Cleo以5%的复利投资了100美元。也就是说，利息是当前存款（包括获得的利息）的5%，：(利息 = 0.05×当前存款)Cleo在第一年投资100美元的盈利是5%—得到了105美元。下一年的盈利是105美元的5%—即5.25美元，依此类推。请编写一个程序，计算多少年后，Cleo的投资价值才能超过Daphne的投资价值，并显示此时两个人的投资价值。1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const double k_dSimpleInterest = 0.1; const double k_dCompoundInterest = 0.05; const double k_dDaphneBase = 100; const double k_dCleoBase = 100; unsigned uYears = 0; double dDaphneTotal = k_dDaphneBase, dCleoTotal = k_dCleoBase; do &#123; dDaphneTotal += k_dDaphneBase * k_dSimpleInterest; dCleoTotal += dCleoTotal * k_dCompoundInterest; ++uYears; cout &lt;&lt; uYears &lt;&lt; ": " &lt;&lt; dDaphneTotal &lt;&lt; "\t" &lt;&lt; dCleoTotal &lt;&lt; endl; &#125; while (dDaphneTotal &gt;= dCleoTotal); cout &lt;&lt; endl; cout &lt;&lt; uYears &lt;&lt; "年后，" &lt;&lt; "Cleo的财富将超过Daphne，前者将达到$" &lt;&lt; dCleoTotal &lt;&lt; "、后者$" &lt;&lt; dDaphneTotal &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 5.销售一本书，输入全年中每个月的销售量（图书数量，而不是销售额）。程序通过循环，使用初始化为月份字符串的char *数组（或string对象数组）逐月进行提示，并将输入的数据储存在一个int数组中。然后，程序计算数组中各元素的总数，并报告这一年的销售情况。1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; unsigned lstMonthlySales[12]; const string k_months[] = &#123;"1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"&#125;; cout &lt;&lt; "输入每月销售量。" &lt;&lt; endl; for (int i = 0; i &lt; 12; ++i) &#123; cout &lt;&lt; k_months[i] &lt;&lt; "："; cin &gt;&gt; lstMonthlySales[i]; &#125; unsigned uSum = 0; for (int i = 0; i &lt; 12; ++i) &#123; uSum += lstMonthlySales[i]; &#125; cout &lt;&lt; "全年销售总量" &lt;&lt; uSum &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 6.使用一个二维数组来存储输入—3年中每个月的销售量。程序将报告每年销售量以及三年的总销售量123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; unsigned lstMonthlySales[3][12]; const string k_months[] = &#123;"1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"&#125;; for (int i = 0; i &lt; 3; ++i) &#123; cout &lt;&lt; "输入第" &lt;&lt; i + 1 &lt;&lt; "年每月销售量。" &lt;&lt; endl; for (int j = 0; j &lt; 12; ++j) &#123; cout &lt;&lt; k_months[j] &lt;&lt; "："; cin &gt;&gt; lstMonthlySales[i][j]; &#125; cout &lt;&lt; endl; &#125; for (int i = 0; i &lt; 3; ++i) &#123; unsigned uSum = 0; for (int j = 0; j &lt; 12; ++j) &#123; uSum += lstMonthlySales[i][j]; &#125; cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "年销售总量" &lt;&lt; uSum &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 7.设计一个名为car的结构，用它存储下述有关汽车的信息：生产商（存储在字符数组或string对象中的字符串）、生产年份（整数）。编写一个程序，向用户询问有多少辆汽车。随后，程序使用new来创建一个由相应数量的car结构组成的动态数组。接下来，程序提示用户输入每辆车的生产商（可能由多个单词组成）和年份信息。请注意，这需要特别小心，因为它将交替读取数值和字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;struct TCar&#123; string strMaker; unsigned uBulitYear;&#125;;int main(void)&#123; cout &lt;&lt; "How many cars do you wish to catalog? "; //unsigned int unsigned uCatalogNum; cin &gt;&gt; uCatalogNum; cin.get(); // 指针类型 new一个内存空间 TCar *pCarsLst = new TCar[uCatalogNum]; for (unsigned i = 0; i &lt; uCatalogNum; ++i) &#123; cout &lt;&lt; "Car #" &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; endl; cout &lt;&lt; "Please enter the make: "; getline(cin, pCarsLst[i].strMaker); //不包含换行符 cout &lt;&lt; "Please enter the year made: "; cin &gt;&gt; pCarsLst[i].uBulitYear; cin.get(); //获取换行符 &#125; cout &lt;&lt; "Here is your collection: " &lt;&lt; endl; for (unsigned i = 0; i &lt; uCatalogNum; ++i) &#123; //数组本身就是指针，默认指向第一个元素 cout &lt;&lt; pCarsLst[i].uBulitYear &lt;&lt; " " &lt;&lt; pCarsLst[i].strMaker &lt;&lt; endl; &#125; //清空指针指向并指向空的位置 delete[] pCarsLst; pCarsLst = NULL; cout &lt;&lt; endl; return (0);&#125; 8.编写一个程序，它使用一个char数组和循环来每次读取一个单词，直到用户输入done为止。随后，该程序指出用户输入了多少个单词（不包括done在内）12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; cout &lt;&lt; "Enter words (to stop, type the word done): "; //只读 不能做修改 //const char *:char类型指针变量 //const k_szDone: 常量变量 const char *const k_szDone = "done"; const unsigned k_uSize = 64; int cntWord = -1; //计数器. // 字符串 char word[k_uSize]; do &#123; ++cntWord; cin &gt;&gt; word; &#125; while (strcmp(k_szDone, word)); //比较两字符串是否相等 cout &lt;&lt; "You entered a total of " &lt;&lt; cntWord &lt;&lt; " words." &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125;---------------------Enter words (to stop, type the word done): hello hh hgx done hanYou entered a total of 3 words. 9.重写上面程序，使用string和关系运算符12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; cout &lt;&lt; "Enter words (to stop, type the word done): "; //常量字符串(char数组) const string k_strDone = "done"; int cntWord = -1; string strWord; do &#123; ++cntWord; cin &gt;&gt; strWord; &#125; while (k_strDone != strWord); cout &lt;&lt; "You entered a total of " &lt;&lt; cntWord &lt;&lt; " words." &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 10.编写一个使用嵌套循环的程序，要求用户输入一个值，指出要显示多少行。然后，程序将显示相应行数的星号，其中第一行包括一个星号，第二行包括两个星号，依此类推。没哟星星用句号填充12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main(void)&#123; const char k_ch1 = '.'; const char k_ch2 = '*'; cout &lt;&lt; "Enter number of rows: "; unsigned uRows; cin &gt;&gt; uRows; // 分配内存 输入大小的平方(输出的是正方形) char *pCharLst = new char[uRows * uRows]; for (unsigned i = 0; i &lt; uRows; ++i) &#123; for (unsigned j = 0; j &lt; uRows - i - 1; ++j) &#123; pCharLst[i * uRows + j] = k_ch1; &#125; for (unsigned j = uRows - i - 1; j &lt; uRows; ++j) &#123; pCharLst[i * uRows + j] = k_ch2; &#125; &#125; for (unsigned i = 0; i &lt; uRows * uRows; ++i) &#123; cout &lt;&lt; pCharLst[i]; if (0 == (i + 1) % uRows) &#123; cout &lt;&lt; endl; &#125; &#125; delete[] pCharLst; pCharLst = NULL; cout &lt;&lt; endl; return (0);&#125;----------------------------------.....*....**...***..****.***********]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础知识03]]></title>
    <url>%2F2019%2F05%2F21%2FC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8603%2F</url>
    <content type="text"><![CDATA[第三章：复合类型 数组数组（array）是一种数据格式，能够存储多个同类型的值数组声明和索引 声明数组： 存储在每个元素中的值的类型； 数组名； 数组中的元素数。 typeName arrayName[arraySize] 数组元素下标从0开始，arrName[0]第一个元素. 数组初始化 typeName arrayName[arraySize]={xx,xx,xx}arrayName[index] = xxx //赋值arrName[] = {xx,xxx} //长度为2 只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组。可以使用下标分别给数组中的元素赋值。提供的值可以少于数组的元素数目,其他元素已0填充。初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个数 字符串字符串是存储在内存的连续字节中的一系列字符(char数组)，并以空字符（null character）结尾，空字符被写作\0，其ASCII码为0，用来标记字符串的结尾 字符串初始化 char str[3]={‘h’,’g’,’x’,’\0’} //字符串char str[3]={‘h’,’g’,’x’,’h’} //非字符串char str[] = “hello” //包括”\0”的字符串 字符数组初始化为字符串(“”包含原始字符和\0) 字符串截取只需要在截取的字符数组的索引赋值“\0” 字符串输入 cin键盘输入字符串，不能使用空格字符(cin使用空格、制表符、和换行符来确定字符串借宿字符，所以只能接收一个单词，并自动在此单词后添加\0)读取一行在istream中提供了面向行的成员函数“getline()”和“get()”,直到读取换行符。cin.getline()丢弃换行符,参数1：需要存储输入内容的名称，参数2：读取的字符数(10的话只能读取9个字符) cin.getline(name,size) cin.get()将换行符保留在输入序列中， 第一种是参数和getline类似。 第二种不带任何参数的get,可以读取下一个字符(包括换行符)因此可以用它来处理换行符，为读取下一行输入做好准备 123cin.get(name,size) //读取第一行cin.get() //读取换行cin.get(name,size) //读取第二行 第三种有参和无参结合使用. cin,get(name,size).get() 读取空行当getline( )或get( )读取空行时，将设置失效位，接下来的输入将被阻断，可以使用”cin.clear()”恢复使用数字和字符串12345678910cin &gt;&gt; year;char address[90];cin.getline(address,90)---------------------------------当用户输入year时回车直接运行程序，不回让输入address,因为cin.getline获取换行符，就默认没有内容，并不包含换行符，结速。解决办法：cin&gt;&gt;year; //cin.get();//获取换行符或(cin&gt;&gt;year).get() string类C++98标准通过添加string类扩展了C++库，因此现在可以string类型的变量（使用C++的话说是对象）而不是字符数组来存储字符串。注意：使用string类，必须包含头文件string(std空间)123#include&lt;iostream&gt;#include&lt;string&gt;using namespace std 可以使用数组表示法来访问存储在string对象中的字符 可以使用cout来显示string对象 可以使用cin来将键盘输入存储到string对象中 可以使用C-风格字符串来初始化string对象 声明并初始化 string str1 //声明string str2 = “Hello” //声明并初始化 赋值拼接 一个string对象赋给另一个string对象,可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾。使用函数strcpy( )将字符串复制到字符数组中，使用函数strcat( )将字符串附加到字符数组末尾，注意数组大小 strcpy(charr1,charr2) //赋值2到1strcat(charr1,charr2) //追加2到1的末尾 结构初介绍结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。因此创建结构包括两步。首先，定义结构描述—它描述并标记了能够存储在结构中的各种数据类型。然后按描述创建结构变量（结构数据对象）关键字struct定义过结构后可以创建结构类型变量，在C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。在C++中，省略struct不会出错 程序中使用结构 结构的声明一般放在main()函数外面 并用struct修饰，C++不提倡使用外部变量，但是提倡使用外部结构声明。和数组一样，使用由逗号分隔值列表，并将这些值用花括号括起。在该程序中，每个值占一行，但也可以将它们全部放在同一行中。只是应用逗号将它们分开：12345678struct stu&#123; string name; int age;&#125;;int main()&#123; stu stu1=&#123;"xiaoming",18&#125;; return 0;&#125; 可将每个结构成员看作是相应类型的变量123stu stu2;stu2.name="xiaohong";stu2.age=20; 可以将结构作为参数传递给函数，也可以让函数返回一个结构。另外，还可以使用赋值运算符（=）将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组 结构数组 可以创建元素为结构的数组，方法和创建基本类型数组完全相同 要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个元素都是结构，因此可以使用结构初始化的方式来提供它的值。因此，最终结果为一个被括在花括号中、用逗号分隔的值列表，其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：1234stu stu1[1]=&#123; &#123;"xx",19&#125;, &#123;"yy",20&#125;&#125;; 共用体共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型，共用体的句法与结构相似，但含义不同12345union demo&#123; int int_val; long long_val; double double_val;&#125;; 可以使用one4all变量来存储int、long或double，条件是在不同的时间进行（共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度）当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间 枚举C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按严格的限制进行。使用enum的句法与使用结构相似 enum color(red,yellow,green,blue) 让color成为新类型的名称；color被称为枚举 将red、yellow等作为符号常量(枚举量)，它们对应整数值0～3 可以用枚举名来声明这种类型的变量： “color band;”对于枚举，只定义了赋值运算符 设置枚举量 可以使用赋值运算符来显式地设置枚举量的值,指定的值必须是整数,也可以只显式地定义其中一些枚举量的值 enum color(red=1,green=2,blue) //blue=3 指针指针是一个变量，其存储的是值的地址，而不是值本身只需对变量应用地址运算符（&amp;），就可以获得它的位置；例如，如果home是一个变量，则&amp;home是它的地址12int a =10;cout&lt;&lt;&amp;a&lt;&lt;endl; //取取值 处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—指针用于存储值的地址。因此，指针名表示的是地址。*运算符被称为间接值（indirect velue）或解除引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值（这和乘法使用的符号相同。123int num =10;int *p； //指针p = &amp;num; //指针指向num地址 声明和初始化指针 指针声明必须指定指针指向的数据的类型 char* p1,p2; 野指针 在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址 指针和数字 指针不是整型，虽然计算机通常把地址当作整数来处理。从概念上看，指针与整数是截然不同的类型。 new 在C语言中，可以用库函数malloc( )来分配内存；在C++中仍然可以这样做，但C++还有更好的方法—new运算符 程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。下面是一个这样的示例 int * p = new int; new int告诉程序，需要适合存储int的内存。new运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针 为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下 typeName * pointName= new typeName; 对于指针，需要指出的另一点是，new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈（stack）的内存区域中，而new从被称为堆（heap）或自由存储区（free store）的内存区域分配内存 delete释放内存 当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是delete运算符，它使得在使用完内存后，能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放（free）的内存可供程序的其他部分使用。使用delete时，后面要加上指向内存块的指针（这些内存块最初是用new分配的），释放内存，但不会删除指针本身，可以使他指向新的内存用，一定要和new成对用，否则会有内存泄漏危险。123int * p = new int;...delete ps； new来创建动态数组 创建动态数组很容易；只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素数目 int *p = new int[10];dekete [] p; 它指向包含10个int值的内存块中的第1个元素，假设int占4个字节，则将手指沿正确的方向移动4个字节，手指将指向第2个元素。总共有10个元素，这就是手指的移动范围。因此，new语句提供了识别内存块中每个元素所需的全部信息。使用第一个元素p[0],第二个p[1]… 指针和数组 在多数情况下，C++将数组名视为数组的第一个元素的地址，一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。使用new来创建数组以及使用指针来访问不同的元素很简单。只要把指针当作数组名对待即可C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义；这将得到两个元素的间隔。 数组的替代品vector模板类vector类似于string类，也是一种动态数组。您可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的 vector vt(n_elem) //n_elem整型 vector类的功能比数组强大，但付出的代价是效率稍低。如果您需要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便和安全。有鉴于此，C++11新增了模板类array，它也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。要创建array对象，需要包含头文件array。array对象的创建语法与vector稍有不同： array&lt;typeName,n_elem&gt; arr 问答声明一个长度100个short数组 short arr[100]; 使用模版array声明上面数组 array&lt;short,100&gt;arr; 取数组第二个元素的值 arr[1]; char数组转为字符串 char str[]=”hello”; string对象声明和赋值string str=”Hello”; 结构体声明和初始化123456struct fish&#123; char kind[20]; int weight; float length;&#125;;fish petes=&#123;"trout",12,22.22&#125; 枚举的声明和指定值 enum response{yes=0,no=1,maybe=2} ted是double变量，声明一个指向ted的指针，并显示此值 double pd = &amp;ted；cout&lt;&lt; pd &lt;&lt;”\n”; 声明一折指针指向长度10的float数组，并显示第一个和最后一个值 float *pt =arr;cout&lt;&lt;pt[0]&lt;&lt;pt[9]&lt;&lt;”\n”; 输入正整数长度创建一个动态int数组，分别用new和vector对象 包含iostream 和vector头文件unsigned int size;cin &gt;&gt;size;int *p =new int(size);vector dv(size); （int *）”HelloWorld”打印什么 是有效的，打印字符串的地址，转化为int指针。 给上面结构体动态分配内存，在取出该结构体的成员值 fish *p = new fish;cout&lt;&lt;”输入 kind:”;cin &gt;&gt; p-&gt;kind; 声明一个vector对象和一个array对象，分别包含10个string对象，使用const指定要包含的string对象数1234567#include&lt;string&gt;#include&lt;vector&gt;#include&lt;array&gt;const int Num&#123;10&#125;; //const int Num=10...std::vector&lt;std::string&gt; vstr(Num);std::array&lt;std::string,Num&gt;astr; 代码1.get和getline练习1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; string strFirstname; cout &lt;&lt; "What is your first name? "; getline(cin, strFirstname); string strLastname; cout &lt;&lt; "What is your last name? "; cin &gt;&gt; strLastname; char chGrade; cout &lt;&lt; "What letter grade do you deserve? "; cin &gt;&gt; chGrade; unsigned unAge; cout &lt;&lt; "What is your age? "; cin &gt;&gt; unAge; cout &lt;&lt; "Name: " &lt;&lt; strLastname &lt;&lt; ", " &lt;&lt; strFirstname &lt;&lt; endl; cout &lt;&lt; "Grade: " &lt;&lt; char(chGrade + 1) &lt;&lt; endl; cout &lt;&lt; "Age: " &lt;&lt; unAge &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125;-----------------------------------What is your first name? han gxWhat is your last name? xxWhat letter grade do you deserve? nWhat is your age? 18Name: xx, han gxGrade: oAge: 18 2.要求用户首先输入其名，然后输入其姓；然后程序使用一个逗号和空格将姓和名组合起来，并存储和显示组合结果。请使用string对象和头文件string中的函数。123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;int main(void)&#123; string strFirstname; cout &lt;&lt; "Enter your first name: "; cin &gt;&gt; strFirstname; string strLastname; cout &lt;&lt; "Enter your last name: "; cin &gt;&gt; strLastname; string strInfo = strLastname + ", " + strFirstname; cout &lt;&lt; "Here’s the information in a single string: " &lt;&lt; strInfo; cout &lt;&lt; endl; return (0);&#125; 3.结构CandyBar包含3个成员。第一个成员存储了糖块的品牌；第二个成员存储糖块的重量（可以有小数）；第三个成员存储了糖块的卡路里含量（整数）。请编写一个程序，声明这个结构，创建一个名为snack的CandyBar变量，并将其成员分别初始化为“Mocha Munch”、2.3和350。初始化应在声明snack时进行。最后，程序显示snack变量的内容。123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;struct TCandyBar&#123; string name; double weight; double calories;&#125;;int main(void)&#123; TCandyBar snack = &#123;"Mocha Munch", 2.3, 350&#125;; cout &lt;&lt; snack.name &lt;&lt; "\n" &lt;&lt; snack.weight &lt;&lt; "\n" &lt;&lt; snack.calories &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 4.上面结构体包含三个成员，初始化并显示1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;struct TCandyBar&#123; string name; double weight; double calories;&#125;;int main(void)&#123; TCandyBar snack[] = &#123;&#123;"Mocha Munch", 2.3, 350&#125;, &#123;"阿尔卑斯", 6.3, 310&#125;, &#123;"优の良品", 2.1, 291&#125;&#125;; cout &lt;&lt; snack[0].name &lt;&lt; "\t" &lt;&lt; snack[0].weight &lt;&lt; "\t" &lt;&lt; snack[0].calories &lt;&lt; endl; cout &lt;&lt; snack[1].name &lt;&lt; "\t" &lt;&lt; snack[1].weight &lt;&lt; "\t" &lt;&lt; snack[1].calories &lt;&lt; endl; cout &lt;&lt; snack[2].name &lt;&lt; "\t" &lt;&lt; snack[2].weight &lt;&lt; "\t" &lt;&lt; snack[2].calories &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 5.程序将请求用户输入信息，然后显示这些信息。请使用cin（或它的方法）和cout,使用结构体123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;struct TPizza&#123; string company_name; double diameter; double weight;&#125;;int main(void)&#123; TPizza pizza; cout &lt;&lt; "输入披萨名："; getline(cin, pizza.company_name); cout &lt;&lt; "输入披萨直径（厘米）："; cin &gt;&gt; pizza.diameter; cout &lt;&lt; "输入披萨重量（克）："; cin &gt;&gt; pizza.weight; cout &lt;&lt; pizza.company_name &lt;&lt; "公司出品直径为" &lt;&lt; pizza.diameter &lt;&lt; "厘米重量为" &lt;&lt; pizza.weight &lt;&lt; "克的披萨" &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 6.使用new来为结构分配内存（上方程序），而不是声明一个结构变量12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::cin;using std::endl;using std::string;struct TPizza&#123; string company_name; double diameter; double weight;&#125;;int main (void) &#123; TPizza* p_pizza = new TPizza; cout &lt;&lt; "输入披萨直径（厘米）："; cin &gt;&gt; p_pizza-&gt;diameter; // cin忽略输入流中的空白符（回车符、空格符、制表符），回车符仍保留在输入流中 cout &lt;&lt; "输入披萨名："; cin.get(); // 提取先前留在输入流中的回车符，否则下面的getline()不会等待输入，而直接读取输入流中已有的回车符 getline(cin, p_pizza-&gt;company_name); cout &lt;&lt; "输入披萨重量（克）："; cin &gt;&gt; p_pizza-&gt;weight; cout &lt;&lt; p_pizza-&gt;company_name &lt;&lt; "公司出品直径为" &lt;&lt; p_pizza-&gt;diameter &lt;&lt; "厘米重量为" &lt;&lt; p_pizza-&gt;weight &lt;&lt; "克的披萨" &lt;&lt; endl; delete p_pizza; p_pizza = NULL; //清空指针并把它指向null cout &lt;&lt; endl; return (0);&#125; 7.使用new来动态分配数组，而不是声明一个包含3个元素的CandyBar数组1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;struct TCandyBar&#123; string name; double weight; double calories;&#125;;int main(void)&#123; const unsigned k_candybar_num = 3; TCandyBar *candybar_list = new TCandyBar[k_candybar_num]; candybar_list[0].name = "Mocha Munch"; candybar_list[0].weight = 2.3; candybar_list[0].calories = 350; candybar_list[1].name = "阿尔卑斯"; candybar_list[1].weight = 6.3; candybar_list[1].calories = 310; candybar_list[2].name = "优の良品"; candybar_list[2].weight = 2.1; candybar_list[2].calories = 291; cout &lt;&lt; candybar_list[0].name &lt;&lt; "\t" &lt;&lt; candybar_list[0].weight &lt;&lt; "\t" &lt;&lt; candybar_list[0].calories &lt;&lt; endl; cout &lt;&lt; candybar_list[1].name &lt;&lt; "\t" &lt;&lt; candybar_list[1].weight &lt;&lt; "\t" &lt;&lt; candybar_list[1].calories &lt;&lt; endl; cout &lt;&lt; candybar_list[2].name &lt;&lt; "\t" &lt;&lt; candybar_list[2].weight &lt;&lt; "\t" &lt;&lt; candybar_list[2].calories &lt;&lt; endl; delete[] candybar_list; candybar_list = NULL; cout &lt;&lt; endl; return (0);&#125; 8.编写一个程序，让用户输入三次40码跑的成绩，并显示次数和平均成绩。请使用一个array对象来存储数据1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;using std::array;using std::cin;using std::cout;using std::endl;int main(void)&#123; const unsigned k_times = 3; array&lt;unsigned, k_times&gt; dash_array; cout &lt;&lt; "输入三次40米短跑成绩："; cin &gt;&gt; dash_array[0] &gt;&gt; dash_array[1] &gt;&gt; dash_array[2]; cout &lt;&lt; "共计输入" &lt;&lt; k_times &lt;&lt; "笔短跑成绩，平均分为" &lt;&lt; (dash_array[0] + dash_array[1] + dash_array[2]) / 3 &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础知识05]]></title>
    <url>%2F2019%2F05%2F21%2FC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8605%2F</url>
    <content type="text"><![CDATA[第五章：分支语句和逻辑运算 if语句if有两种格式：if和if else，如果测试条件为true，则if语句将引导程序执行语句或语句块；如果条件是false，程序将跳过这条语句或语句块 if(测试语句){body}if(测试语句){body}else{body} 逻辑表达式C++提供了3种逻辑运算符，分别是逻辑OR（||）、逻辑AND（&amp;&amp;）和逻辑NOT（!） 逻辑OR运算符：||将两个表达式组合在一起。如果原来表达式中的任何一个或全部都为true（或非零），则得到的表达式的值为true；否则，表达式的值为false ，C++规定，||运算符是个顺序点（sequence point）。也是说，先修改左侧的值，再对右侧的值进行判定（C++11的说法是，运算符左边的子表达式先于右边的子表达式） 逻辑AND运算符：&amp;&amp;逻辑AND运算符（&amp;&amp;），也是将两个表达式组合成一个表达式。仅当原来的两个表达式都为true时，得到的表达式的值才为true，&amp;&amp;运算符也是顺序点，因此将首先判定左侧，并且在右侧被判定之前产生所有的副作用。如果左侧为false，则整个逻辑表达式必定为false，在这种情况下，C++将不会再对右侧进行判定 逻辑NOT运算符：!!运算符将它后面的表达式的真值取反。也是说，如果expression为true，则!expression是false；如果expression为false，则!expression是true。更准确地说，如果expression为true或非零，则!expression为false。 其他表示方式标识符and、or和not都是C++保留字，这意味着不能将它们用作变量名等。它们不是关键字，因为它们都是已有语言特性的另一种表示方式。另外，它们并不是C语言中的保留字，但C语言程序可以将它们用作运算符，只要在程序中包含了头文件iso646.h。C++不要求使用头文件. 字符函数库cctypeC++从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype（老式的风格中为ctype.h）中定义的. 函数名 返回值 isalnum() 如果参数是字母数字，即字母或数字，该函数返回true isalpha() 如果参数是字母，该函数返回true iscntrl() 如果参数是控制字符，该函数返回true isdigit() 如果参数是数字（0～9），该函数返回true isgraph() 如果参数是除空格之外的打印字符，该函数返回true islower() 如果参数是小写字母，该函数返回true isprint() 如果参数是打印字符（包括空格），该函数返回true ispunct() 如果参数是标点符号，该函数返回true isspace() 如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符或者垂直制表符，该函数返回true isupper() 如果参数是大写字母，该函数返回true isxdigit() 如果参数是十六进制数字，即0～9、a～f或A～F，该函数返回 tolower() 如果参数是大写字符，则返回其小写，否则返回该参数 toupper() 如果参数是小写字符，则返回其大写，否则返回该参数 运算符”?:”C++有一个常被用来代替if else语句的运算符，这个运算符被称为条件运算符（?:），它是C++中唯一一个需要3个操作数的运算符 表达式1 ? 表达式2 : 表达式3 如果expression1为true，则整个条件表达式的值为expression2的值；否则，整个表达式的值为expression3的值。 switch语句C++的switch语句就像指路牌，告诉计算机接下来应执行哪行代码。执行到switch语句时，程序将跳到使用integer-expression的值标记的那一行，integer-expression必须是一个结果为整数值的表达式。另外，每个标签都必须是整数常量表达式。最常见的标签是int或char常量，也可以是枚举量。如果integer-expression不与任何标签匹配，则程序将跳到标签为default的那一行。Default标签是可选的，如果被省略，而又没有匹配的标签，则程序将跳到switch后面的语句处执行 switch语句与Pascal等语言中类似的语句之间存在重大的差别。C++中的case标签只是行标签，而不是选项之间的界线。也是说，程序跳到switch中特定代码行后，将依次执行之后的所有语句，除非有明确的其他指示。程序不会在执行到下一个case处自动停止，要让程序执行完一组特定语句后停止，必须使用break语句。这将导致程序跳到switch后面的语句处执行 将枚举作为标签通常，cin无法识别枚举类型（它不知道程序员是如何定义它们的），因此该程序要求用户选择选项时输入一个整数。当switch语句将int值和枚举量标签进行比较时，将枚举量提升为int。另外，在while循环测试条件中，也会将枚举量提升为int类型。 123456789101112131415enum (red,orange,yellow)int main()&#123; int code; cin &gt;&gt; code; while (code &gt;=red &amp;&amp; code &lt;= yellow)&#123; switch (code)&#123; case red; cout &lt;&lt; "this is red \n"; break; case orange; cout &lt;&lt; "this is orange \n"; break; case yellow; cout &lt;&lt; "this is yellow \n"; break; &#125; cout &lt;&lt; "no cloro"; cin &gt;&gt;code &#125; return 0;&#125; switch 和 if elseswitch语句和if else语句都允许程序从选项中进行选择。相比之下，if else更通用。switch并不是为处理取值范围而设计的。switch语句中的每一个case标签都必须是一个单独的值。另外，这个值必须是整数（包括char），因此switch无法处理浮点测试。另外case标签值还必须是常量。如果选项涉及取值范围、浮点测试或两个变量的比较，则应使用if else语句.如果所有的选项都可以使用整数常量来标识，则可以使用switch语句或if else语句。由于switch语句是专门为这种情况设计的，因此，如果选项超过两个，则就代码长度和执行速度而言，switch语句的效率更高。 break和continuebreak和continue语句都使程序能够跳过部分代码。可以在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处执行。continue语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657\#include &lt;iostream&gt;const int AirSize = 80;int main()&#123;​ using namespace *std*;​ char line[AirSize];​ int spaces = 0;​ cout &lt;&lt; "Enter a line of text: \n";​ cin.get(line, AirSize);​ cout &lt;&lt; "Complete line:\n"​ &lt;&lt; line &lt;&lt; endl;​ for (int i = 0; line[i] != '\0'; i++)​ &#123;​ cout &lt;&lt; line[i];​ if (line[i] == '.')​ break;​ if (line[i] != ' ')​ continue;​ spaces++;​ &#125;​ cout &lt;&lt; "\n"​ &lt;&lt; spaces &lt;&lt; " spaces\n";​ cout &lt;&lt; "Done.\n";​ return 0;&#125;----------------------------------------Enter a line of text:Hello world, everyone i love you. or you name?Complete line:Hello world, everyone i love you. or you name?Hello world, everyone i love you.5 spacesDone. 该程序让用户输入一行文本。循环将回显每个字符，如果该字符为句点，则使用break结束循环。这表明，可以在某种条件为true时，使用break来结束循环。接下来，程序计算空格数，但不计算其他字符。当字符不为空格时，循环使用continue语句跳过计数部分。continue语句导致该程序跳过循环体的剩余部分，但不会跳过循环的更新表达式。在for循环中，continue语句使程序直接跳到更新表达式处，然后跳到测试表达式处。然而，对于while循环来说，continue将使程序直接跳到测试表达式处，因此while循环体中位于continue之后的更新表达式都将被跳过。 goto语句：和C语言一样，C++也有goto语句。下面的语句将跳到使用paris:作为标签的位置： goto paris; 在大多数情况下（有些人认为，在任何情况下），使用goto语句不好，而应使用结构化控制语句（如if else、switch、continue等）来控制程序的流程 读取数字的循环当程序接受一系列数字时(cin &gt;&gt;n);如果用户输入一个单词，需要对这个输入单词进行处理。程序必须先重置cin，然后才能删除错误输入 1．重置cin以接受新的输入 2．删除错误输入。 3．提示用户再输入 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;const int MAX = 5;int main()&#123; using namespace std; int golf[MAX]; cout &lt;&lt; "Plese enter you scores.\n"; cout &lt;&lt; "you must enter " &lt;&lt; MAX &lt;&lt; " rounds.\n"; int i; for (i = 0; i &lt; MAX; i++) &#123; cout &lt;&lt; "round #" &lt;&lt; i + 1 &lt;&lt; " : "; while (!(cin &gt;&gt; golf[i])) //当输入字母时 为true进入循环 &#123; cin.clear(); //reset input while (cin.get() != '\n') continue; cout &lt;&lt; "please enter a num: "; &#125; &#125; cout &lt;&lt; "end!\n"; return 0;&#125;-----------------------------------------------Plese enter you scores.you must enter 5 rounds.round #1 : 10round #2 : aaplease enter a num: 11round #3 : 33 简单的文件输入\出C++使得将读取键盘输入和在屏幕上显示输出（统称为控制台输入/输出）的技巧用于文件输入/输出（文件I/O），这里只介绍简单的文本文件I/O。 文本I/O和文本文件使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据——文本数据，cin对象负责将文本转换为其他类型。 写入到文本文件中 必须包含头文件fstream。 头文件fstream定义了一个用于处理输出的ofstream类。 需要声明一个或多个ofstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。 必须指明名称空间std；例如，为引用元素ofstream，必须使用编译指令using或前缀std::。 需要将ofstream对象与文件关联起来。为此，方法之一是使用open( )方法。 使用完文件后，应使用方法close( )将其关闭。 可结合使用ofstream对象和运算符&lt;&lt;来输出各种类型的数据。 虽然头文件iostream提供了一个预先定义好的名为cout的ostream对象，但您必须声明自己的ofstream对象，为其命名，并将其同文件关联起来。 ofstream outFile; ofstream fout; outFile.open(“xx.txt”); char filename[50]; cin &gt;&gt;filename; fout.open(filename); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;fstream&gt; //ioint main()&#123; using namespace std; char automobile[50]; int year; double a_price; double b_price; ofstream outFile; //创建文件对象 outFile.open("info.txt"); cout &lt;&lt; "Enter the make and model of automobile: "; cin.getline(automobile, 50); cout &lt;&lt; "enter the model year: "; cin &gt;&gt; year; cout &lt;&lt; "enter the price: "; cin &gt;&gt; a_price; b_price = 0.5 * a_price; //display infomation on screen with cout cout &lt;&lt; fixed; cout.precision(2); cout.setf(ios_base::showpoint); cout &lt;&lt; "make and model: " &lt;&lt; automobile &lt;&lt; endl; cout &lt;&lt; "year: " &lt;&lt; year &lt;&lt; endl; cout &lt;&lt; "was asking $" &lt;&lt; a_price &lt;&lt; endl; cout &lt;&lt; "Now asking $" &lt;&lt; b_price &lt;&lt; endl; //using outFIle outFile &lt;&lt; fixed; outFile.precision(2); outFile.setf(ios_base::showpoint); outFile &lt;&lt; "make and model: " &lt;&lt; automobile &lt;&lt; endl; outFile &lt;&lt; "year: " &lt;&lt; year &lt;&lt; endl; outFile &lt;&lt; "was asking $" &lt;&lt; a_price &lt;&lt; endl; outFile &lt;&lt; "Now asking $" &lt;&lt; b_price &lt;&lt; endl; outFile.close(); return 0;&#125;----------------------------------------------------Enter the make and model of automobile: hello hanenter the model year: 1991enter the price: 100make and model: hello hanyear: 1991was asking $100.00Now asking $50.00---------------------------------------------------info.txt:make and model: hello hanyear: 1991was asking $100.00Now asking $50.00 ofstream对象后，便可以使用方法open( )将该对象特定文件关联起来,程序使用完该文件后，应该将其关闭,方法close( )不需要使用文件名作为参数，这是因为outFile已经同特定的文件关联起来。如果您忘记关闭文件，程序正常终止时将自动关闭它,outFile可使用cout可使用的任何方法。它不但能够使用运算符&lt;&lt;，还可以使用各种格式化方法，如setf( )和precision( )。这些方法只影响调用它们的对象. open()方法：如果路径已经存在文件时，open( )将首先截断该文件，即将其长度截短到零——丢其原有的内容，然后将新的输出加入到该文件中 读取文本文件 必须包含头文件fstream。 头文件fstream定义了一个用于处理输入的ifstream类。 需要声明一个或多个ifstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则 必须指明名称空间std；例如，为引用元素ifstream，必须使用编译指令using或前缀std::。 需要将ifstream对象与文件关联起来。为此，方法之一是使用open( )方法。 使用完文件后，应使用close( )方法将其关闭。 可结合使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据。 可以使用ifstream对象和get( )方法来读取一个字符，使用ifstream对象和getline( )来读取一行字符。 可以结合使用ifstream和eof( )、fail( )等方法来判断输入是否成功。 ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false 虽然头文件iostream提供了一个预先定义好的名为cin的istream对象，但您必须声明自己的ifstream对象，为其命名，并将其同文件关联起来 ifstream inFile; ifstream fin; inFile.open(“xxx.txt”); char filename[50]; cin &gt;&gt; filename; fin.open(filename); 声明一个ifstream对象并将其同文件关联起来后，便可以像使用cin那样使用它。所有可用于cin的操作和方法都可用于ifstream对象,如果试图打开一个不存在的文件用于输入，这种错误将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功打开的首先方法是使用方法is_open( )， 1234inFile.open("info.txt");if (!inFile.is_open())&#123; exit(EXIT_FAILURE)&#125; 如果文件没有被打开，表达式!inFile.isopen( )将为true。函数exit( )的原型是在头文件cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值EXIT_FAILURE。函数exit( )终止程序，s_open( )是C++中相对较新的内容。如果读者的编译器不支持它，可使用较老的方法good( )来代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;fstream&gt; //io#include &lt;cstdlib&gt; //exit()const int SIZE = 60;int main()&#123; using namespace std; char filename[SIZE]; ifstream inFile; cout &lt;&lt; "enter filename:"; cin.getline(filename, SIZE); inFile.open(filename); if (!inFile.is_open()) &#123; cout &lt;&lt; "Could not open file: " &lt;&lt; filename &lt;&lt; endl; exit(EXIT_FAILURE); &#125; double value; double sum = 0.0; int count = 0; inFile &gt;&gt; value; //get first value while (inFile.good()) //while input good and not at EOF &#123; ++count; sum += value; inFile &gt;&gt; value; &#125; if (inFile.eof()) &#123; cout &lt;&lt; "End of file reached.\n"; &#125; else if (inFile.fail()) &#123; cout &lt;&lt; "input terminated by data mismatch.\n"; &#125; else &#123; cout &lt;&lt; "input terminated for unknow reason.\n"; &#125; if (count == 0) &#123; cout &lt;&lt; "No data processed.\n"; &#125; else &#123; cout &lt;&lt; "iteam read: " &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; "sum: " &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; "Average: " &lt;&lt; sum / count &lt;&lt; endl; &#125; inFile.close(); return 0;&#125;-----------------------------------------------------enter filename:test.txtEnd of file reached.iteam read: 11sum: 187Average: 17-----------------------------------------------------目录下必须又test.txt:18 19 18.5 13.5 1416 19.5 20 18 12 18.517.5 读取文件时，有几点需要检查。首先，程序读取文件时不应超过EOF。如果最后一次读取数据时遇到EOF，方法eof( )将返回true。其次，程序可能遇到类型不匹配的情况,如果最后一次读取操作中发生了类型不匹配的情况，方法fail( )将返回true（如果遇到了EOF，该方法也将返回true）最后，可能出现意外的问题，如文件受损或硬件故障。如果最后一次读取文件时发生了这样的问题，方法bad( )将返回true。不要分别检查这些情况，一种更简单的方法是使用good( )方法，该方法在没有发生任何错误时返回true.infile.eof(),infile.fail()由于eof( )只能判断是否到达EOF，而fail( )可用于检查EOF和类型不匹配，因此上述代码首先判断是否到达EOF。这样，如果执行到了else if测试，便可排除EOF，因此，如果fail( )返回true，便可断定导致循环终止的原因是类型不匹配.方法good( )指出最后一次读取输入的操作是否成功，这一点至关重要。这意味着应该在执行读取输入的操作后，立刻应用这种测试。为此，一种标准方法是，在循环之前（首次执行循环测试前）放置一条输入语句，并在循环的末尾（下次执行循环测试之前）放置另一条输入语句”infile&gt;&gt;value” 可以精简while(infile &gt;&gt;value) 问答 if if 和if else有什么区别： if else 效率更好，if成立 else不在判断，而俩if，都会判断一遍。 ch为字符，++ch 和ch+1区别 值相同，但是++ch类型蔚char，可以作为字符打印，ch+1值蔚int,只能作为int打印 创建一个条件表达式，其值为变量的绝对值 (x&lt;0) ? -x:x / (x&gt;=0)x:-x 程序输出什么12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main()&#123; char ch; int ct1, ct2; ct1 = ct2 = 0; while ((ch = cin.get()) != '$') &#123; cout &lt;&lt; ch; ct1++; if (ch = '$') &#123; ct2++; &#125; cout &lt;&lt; ch; &#125; cout &lt;&lt; "ct1 = " &lt;&lt; ct1 &lt;&lt; "; ct2 = " &lt;&lt; ct2 &lt;&lt; "\n"; return 0;&#125;--------------------输入内容------------------------hi!send $10 or $20 now-------------------输出结果-------------------------hi!h$i$!$$send $10 or $20 nows$e$n$d$ $ct1 = 9; ct2 = 9 由于ch=’$’ 而不是ch==’$’’ 因此输出结果会出现上面效果 重写 不要使用break 和continue1234567891011121314151617 int line = 0; char ch; while (cin.get(ch)) &#123; if (ch == 'Q') break; if (ch != '\n') continue; line++; &#125;---------------重写如下------------------int line = 0;char ch;while(cin.get(ch)&amp;&amp; ch!='Q')&#123; if (ch=='\n') line++;&#125; 代码 编写一个程序，读取键盘输入，直到遇到@符号为止，并回显输入（数字除外），同时将大写字符转换为小写，将小写字符转换为大写（别忘了cctype函数系列） 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cctype&gt;int main(void)&#123; using namespace std; const char k_flagEnd = '@'; char ch; while (cin &gt;&gt; ch &amp;&amp; k_flagEnd != ch) &#123; if (isdigit(ch)) &#123; continue; &#125; if (islower(ch)) &#123; ch = (char)toupper(ch); &#125; else if (isupper(ch)) &#123; ch = (char)tolower(ch); &#125; else &#123; ; // nop! &#125; cout &lt;&lt; ch; &#125; cout &lt;&lt; endl; return (0);&#125; 编写一个程序，最多将10个donation值读入到一个double数组中。程序遇到非数字输入时将结束输入，并报告这些数字的平均值以及数组中有多少个数字大于平均值。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;int main(void)&#123; using namespace std; const unsigned k_size = 10; double arrDonation[k_size]; double dSum = 0; unsigned cntDonation = 0; while (cntDonation &lt; k_size &amp;&amp; cin &gt;&gt; arrDonation[cntDonation]) &#123; dSum += arrDonation[cntDonation++]; &#125; double dAverage = dSum / cntDonation; unsigned cntLargerAverage = 0; for (unsigned i = 0; i &lt; k_size; ++i) &#123; if (arrDonation[i] &gt; dAverage) &#123; ++cntLargerAverage; &#125; &#125; cout &lt;&lt; "平均值为" &lt;&lt; dAverage &lt;&lt; "，超过平均值的有" &lt;&lt; cntLargerAverage &lt;&lt; "个。" &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 使用switch编写一个菜单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;int main(void)&#123; using namespace std; cout &lt;&lt; "Please enter one of the following choices: " &lt;&lt; endl; cout &lt;&lt; "c) carnivore\t" &lt;&lt; "p) pianist" &lt;&lt; endl; cout &lt;&lt; "t) tree\t\t" &lt;&lt; "g) game" &lt;&lt; endl; char ch; while (cin &gt;&gt; ch) &#123; switch (ch) &#123; case 'c': &#123; cout &lt;&lt; "A dog is a carnivore. " &lt;&lt; endl; &#125; break; case 'p': &#123; cout &lt;&lt; "Lang Lang is a pianist. " &lt;&lt; endl; &#125; break; case 't': &#123; cout &lt;&lt; "A maple is a tree." &lt;&lt; endl; &#125; break; case 'g': &#123; cout &lt;&lt; "Red alert is a game. " &lt;&lt; endl; &#125; break; default: cout &lt;&lt; "Please enter a c, p, t, or g: "; break; &#125; &#125; cout &lt;&lt; endl; return (0);&#125; 编写一个程序，使用真实姓名、头衔、秘密姓名或成员偏好来列出成员，该程序创建一个由结构组成的小型数组，并将其初始化为适当的值。另外，该程序使用一个循环，让用户在下面的选项中进行选择 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;const unsigned gk_size = 64;enum TPreference&#123; FULLNAME, TITLE, BOPNAME&#125;;struct TBop&#123; char szFullname[gk_size]; // real name char szTitle[gk_size]; // job title char szBopname[gk_size]; // secret BOP name TPreference preference;&#125;;int main(void)&#123; using namespace std; TBop lstBops[] = &#123;&#123;"Yang Yang", "chinamobile", "yangyang.gnu", TITLE&#125;, &#123;"xiao wang", "microsoft", "xiaowang", BOPNAME&#125;, &#123;"xiao liu", "IBM", "xiaoliu", FULLNAME&#125;, &#123;"xiao zhang", "Huawei", "xiaozhang", TITLE&#125;&#125;; bool bDisplay = true; while (bDisplay) &#123; cout &lt;&lt; "Benevolent Order of Programmers Report" &lt;&lt; endl; cout &lt;&lt; "a. display by name" &lt;&lt; "\t" &lt;&lt; "b. display by title" &lt;&lt; endl; cout &lt;&lt; "c. display by bopname" &lt;&lt; "\t" &lt;&lt; "d. display by preference" &lt;&lt; endl; cout &lt;&lt; "q. quit" &lt;&lt; endl; char chAction; if (!(cin &gt;&gt; chAction)) &#123; bDisplay = false; break; &#125; switch (chAction) &#123; case 'a': &#123; for (const auto &amp;e : lstBops) &#123; cout &lt;&lt; e.szFullname &lt;&lt; endl; &#125;; &#125; break; case 'b': &#123; for (const auto &amp;e : lstBops) &#123; cout &lt;&lt; e.szTitle &lt;&lt; endl; &#125;; &#125; break; case 'c': &#123; for (const auto &amp;e : lstBops) &#123; cout &lt;&lt; e.szBopname &lt;&lt; endl; &#125;; &#125; break; case 'd': &#123; for (const auto &amp;e : lstBops) &#123; if (FULLNAME == e.preference) &#123; cout &lt;&lt; e.szFullname &lt;&lt; endl; &#125; else if (TITLE == e.preference) &#123; cout &lt;&lt; e.szTitle &lt;&lt; endl; &#125; else if (BOPNAME == e.preference) &#123; cout &lt;&lt; e.szBopname &lt;&lt; endl; &#125; else &#123; ; &#125; &#125; &#125; break; case 'q': &#123; cout &lt;&lt; "Bye! " &lt;&lt; endl; bDisplay = false; &#125; break; default: &#123; cout &lt;&lt; "Error! " &lt;&lt; endl; &#125; break; &#125; &#125; cout &lt;&lt; endl; return (0);&#125; 计算税收，5000下不收 5001-1500:10%；15001-35000：15%；35000+：20%,当用户输入负数或非数字时，循环结束 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;int main(void)&#123; using namespace std; // |-----|----------|--------------------|-----... // 0% (5K) 10% (1.5W) 15% (3.5W) 20% double tvarp; while (cin &gt;&gt; tvarp &amp;&amp; tvarp &gt;= 0) &#123; double arrFourSection[4] = &#123;5000, 10000, 20000&#125;; if (tvarp &lt;= 5000) &#123; arrFourSection[0] = tvarp; arrFourSection[1] = arrFourSection[2] = arrFourSection[3] = 0; &#125; else if ((tvarp -= 5000) &lt;= 10000) &#123; arrFourSection[1] = tvarp; arrFourSection[2] = arrFourSection[3] = 0; &#125; else if ((tvarp -= 10000) &lt;= 20000) &#123; arrFourSection[2] = tvarp; arrFourSection[3] = 0; &#125; else &#123; arrFourSection[3] = tvarp - 20000; &#125; cout &lt;&lt; "税收明细如下：" &lt;&lt; arrFourSection[0] &lt;&lt; " * 0% + " &lt;&lt; arrFourSection[1] &lt;&lt; " * 10% + " &lt;&lt; arrFourSection[2] &lt;&lt; " * 15% + " &lt;&lt; arrFourSection[3] &lt;&lt; " * 20% " &lt;&lt; " = " &lt;&lt; arrFourSection[0] * 0 + arrFourSection[1] * 0.1 + arrFourSection[2] * 0.15 + arrFourSection[3] * 0.2 &lt;&lt; endl; &#125; cout &lt;&lt; endl; return (0);&#125; 用户输入捐献者数目，然后要求用户输入每一个捐献者的姓名和款项。这些信息被储存在一个动态分配的结构数组中。每个结构有两个成员：用来储存姓名的字符数组（或string对象）和用来存储款项的double成员。读取所有的数据后，程序将显示所有捐款超过10000的捐款者的姓名及其捐款数额。该列表前应包含一个标题，指出下面的捐款者是重要捐款人（Grand Patrons）。然后，程序将列出其他的捐款者，该列表要以Patrons开头。如果某种类别没有捐款者，则程序将打印单词“none”。该程序只显示这两种类别，而不进行排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct TDonor&#123; string name; double amount;&#125;;int main(void)&#123; cout &lt;&lt; "输入捐赠人数："; unsigned num_donor; cin &gt;&gt; num_donor; TDonor *const p_donor = new TDonor[num_donor]; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; cout &lt;&lt; "输入捐赠人姓名："; cin &gt;&gt; p_donor[i].name; cout &lt;&lt; "输入捐赠金额："; cin &gt;&gt; p_donor[i].amount; &#125; cout &lt;&lt; "荣誉捐赠者：" &lt;&lt; endl; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; if (p_donor[i].amount &gt;= 10000) &#123; cout &lt;&lt; p_donor[i].name &lt;&lt; endl; &#125; &#125; cout &lt;&lt; "普通捐赠者：" &lt;&lt; endl; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; if (p_donor[i].amount &lt; 10000) &#123; cout &lt;&lt; p_donor[i].name &lt;&lt; endl; &#125; &#125; delete[] p_donor; cout &lt;&lt; endl; return (0);&#125; 编写一个程序，它每次读取一个单词，直到用户只输入q。然后，该程序指出有多少个单词以元音打头，有多少个单词以辅音打头，还有多少个单词不属于这两类。为此，方法之一是，使用isalpha( )来区分以字母和其他字符打头的单词，然后对于通过了isalpha( )测试的单词，使用if或switch语句来确定哪些以元音打头 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;int main(void)&#123; using namespace std; unsigned cntVowels = 0, cntConsonants = 0, cntOthers = 0; cout &lt;&lt; "输入单词，字母q结束："; string word; while (cin &gt;&gt; word &amp;&amp; "q" != word) &#123; char &amp;first_char = word[0]; if (!isalpha(first_char)) &#123; ++cntOthers; &#125; else if ('a' == first_char || 'A' == first_char || 'e' == first_char || 'E' == first_char || 'i' == first_char || 'I' == first_char || 'o' == first_char || 'O' == first_char || 'u' == first_char || 'U' == first_char) &#123; ++cntVowels; &#125; else &#123; ++cntConsonants; &#125; &#125; cout &lt;&lt; "元音开头的单词" &lt;&lt; cntVowels &lt;&lt; "个、辅音单词" &lt;&lt; cntConsonants &lt;&lt; "个、其他" &lt;&lt; cntOthers &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 编写一个程序，它打开一个文件文件，逐个字符地读取该文件，直到到达文件末尾，然后指出该文件中包含多少个字符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;const int SIZE = 60;int main()&#123; //-----打开测试文件U6p8test.txt- using namespace std; char filename[SIZE]; ifstream inFile; cout &lt;&lt; "Enter name of data file: "; cin.getline(filename, SIZE); inFile.open(filename); if (!inFile.is_open()) &#123; cout &lt;&lt; "Could not open the file " &lt;&lt; filename &lt;&lt; endl; cout &lt;&lt; "Program terminating.\n"; exit(EXIT_FAILURE); &#125; //开始读取数据 char value; int count = 0; inFile &gt;&gt; value; while (inFile.good()) &#123; ++count; inFile &gt;&gt; value; &#125; //文件读取末尾 if (inFile.eof()) cout &lt;&lt; "End of file reached.\n"; else if (inFile.fail()) cout &lt;&lt; "Input terminated by data mismatch.\n"; else cout &lt;&lt; "Input terminated for unknown reason.\n"; if (count == 0) cout &lt;&lt; "No data processed.\n"; else &#123; cout &lt;&lt; "chars: " &lt;&lt; count &lt;&lt; endl; &#125; inFile.close(); return 0;&#125; 完成编程练习6，但从文件中读取所需的信息。该文件的第一项应为捐款人数，余下的内容应为成对的行。在每一对中，第一行为捐款人姓名，第二行为捐款数额 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;struct TDonor&#123; string name; double amount;&#125;;int main(void)&#123; ifstream ifs("contributor_(for_linux).txt"); unsigned num_donor; ifs &gt;&gt; num_donor; TDonor *const p_donor = new TDonor[num_donor]; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; ifs.get(); getline(ifs, p_donor[i].name); ifs &gt;&gt; p_donor[i].amount; &#125; cout &lt;&lt; "荣誉捐赠者：" &lt;&lt; endl; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; if (p_donor[i].amount &gt;= 10000) &#123; cout &lt;&lt; p_donor[i].name &lt;&lt; endl; &#125; &#125; cout &lt;&lt; "普通捐赠者：" &lt;&lt; endl; for (unsigned i = 0; i &lt; num_donor; ++i) &#123; if (p_donor[i].amount &lt; 10000) &#123; cout &lt;&lt; p_donor[i].name &lt;&lt; endl; &#125; &#125; delete[] p_donor; cout &lt;&lt; endl; return (0);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础知识01]]></title>
    <url>%2F2019%2F05%2F21%2FC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601%2F</url>
    <content type="text"><![CDATA[第一章：基础了解 基础知识：C++程序的基础模块叫什么 函数 #include什么作用 会在编译之前，使用iostream文件内容替换该编译指令 using namespace std什么作用 使程序可以使用std名称空间的定义，放在函数定义之前，让所有函数都能使用名称空间std中所有元素放在指定函数定义中，让该函数能够使用在特定的函数中使用using std::cout，让该函数能够使用指定元素cout。完全不使用编译指令，而使用命名空间元素时 使用 1std::cout&lt;&lt;"Hello"&lt;&lt;std:endl 打印hello并开始新的一行 12cout &lt;&lt; "hello\n"; cout &lt;&lt; "hello" &lt;&lt; endl; 创建变量 类型 变量名 1int num 赋值 变量=值 键盘输入赋值 1cin &gt;&gt; num 打印拼接1cout &lt;&lt; "num value is"&lt;&lt; num &lt;&lt; "，is int type" &lt;&lt;endl 函数定义 返回值类型 函数名 （参数）在没有函数返回值的情况下可以不使用“return”，也可以使用“return;” 123int froop(double t); //函数传入double类型，返回int类型值void noreturn(int n); //传入一个int参数，没有返回值int prune(void); //没有参数传入，但是返回一个int类型值 代码：1.HelloWorld123456789//中文如果乱码将文件改成GBK编码#include &lt;iostream&gt;int main(void)&#123; using std::cout; using std::endl; cout &lt;&lt; "我是小星星,河南人！！" &lt;&lt;endl; cout &lt;&lt; endl; return(0);&#125; 2.用户键盘输入一个整形，并计算返回12345678910#include &lt;iostream&gt;int main(void)&#123; using namespace std; //命名空间 double inputNum; //定义一个双精度变量 cout &lt;&lt; "输入一个double类型的数：" &lt;&lt; endl; cin &gt;&gt; inputNum; //获取输入的值并赋给定义的变量 cout &lt;&lt; "计算乘2减3的结果:" &lt;&lt;inputNum * 2 -3 &lt;&lt; "。结束计算" &lt;&lt; endl; cout &lt;&lt; endl; return(0);&#125; 3.用户自定义函数12345678910111213141516171819202122232425#include &lt;iostream&gt;//命名空间using std::cin;using std::cout;using std::endl;//定义函数1void print_one(void)&#123; cout &lt;&lt; "函数一" &lt;&lt; endl;&#125;//定义函数2void print_two(void)&#123; cout &lt;&lt; "函数二" &lt;&lt; endl;&#125;int main(void)&#123; //调用函数 print_one(); print_two(); cout &lt;&lt; endl; return (0);&#125; 4.用户输入年两，计算包含多少月12345678910111213141516#include &lt;iostream&gt;int main (void) &#123; using std::cout; using std::cin; using std::endl; int age; cout &lt;&lt; "Enter your age: "; cin &gt;&gt; age; cout &lt;&lt; "Your age in months is " &lt;&lt; age * 12 &lt;&lt; endl; cout &lt;&lt; endl; return (0);&#125; 5.使用自定义函数完成华氏度和摄氏度的转换 华氏温度 = 1.8 * 摄氏度 + 32 12345678910111213141516#include &lt;iostream&gt;double cal(double celsius)&#123; return (1.8 * celsius + 32.0);&#125;int main(void)&#123; using namespace std; double celsius; cout &lt;&lt; "请输入当前温度(摄氏度)："; cin &gt;&gt; celsius; cout &lt;&lt; "当前华氏度：" &lt;&lt; cal(celsius) &lt;&lt; "华氏度"; cout &lt;&lt; endl; return (0);&#125; 6.用户输入小时和分钟并格式化 xx:xx1234567891011121314151617181920#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;void fmtTime(int hour, int minute)&#123; cout &lt;&lt; "当前时间：(" &lt;&lt; hour &lt;&lt; ":" &lt;&lt; minute &lt;&lt; ")." &lt;&lt; endl;&#125;int main(void)&#123; int hour, minute; cout &lt;&lt; "请输入当前小时:"; cin &gt;&gt; hour; cout &lt;&lt; "请输入分钟："; cin &gt;&gt; minute; fmtTime(hour, minute); cout &lt;&lt; endl; return (0);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCODE-C++环境配置]]></title>
    <url>%2F2019%2F05%2F20%2FVSCODE-C-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[PicGO图床快捷方式： 粘贴图片路径上传：CTRL+ALT+U 选择图片文件上传: CTRL+ALT+E 从输入框上传图片：CTRL+ALT+O VSCODE下载:VSCODE下载地址 mingw64离线包下载：mingw64离线包下载： 环境配置：mingw64\bin配置到path变量 vscode 安装插件! 选择c++源码文件夹,新建.vscode目录 配置“launch.json” 1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.exe",// 将要进行调试的程序的路径 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "$&#123;workspaceRoot&#125;", // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 "environment": [], "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "MIMode": "gdb", "miDebuggerPath": "C:\\mingw64\\bin\\gdb.exe", //注意这里要与MinGw的路径对应 "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ], "preLaunchTask": "g++", // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &#125; ]&#125; 配置tasks.json 1234567891011121314151617&#123; "version": "2.0.0", "command": "g++", "args": ["-g","$&#123;file&#125;","-o","$&#123;fileBasenameNoExtension&#125;.exe"], // 编译命令参数 "problemMatcher": &#123; "owner": "cpp", "fileLocation": ["relative", "$&#123;workspaceRoot&#125;"], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125; &#125; 配置”settings.json” 12345678&#123; "files.exclude": &#123; "**/.classpath": true, "**/.project": true, "**/.settings": true, "**/.factorypath": true &#125;&#125;]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>VSCODE</tag>
      </tags>
  </entry>
</search>
